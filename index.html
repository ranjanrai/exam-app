<!doctype html>
<html lang="en">
<head>
<!-- Firebase SDK -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getFirestore, collection, doc, setDoc, getDocs, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
  import { getStorage } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

  
  const firebaseConfig = {
    apiKey: "AIzaSyC7X0B65qfWiSkSaC_-dXElw687ZmVM9gU",
    authDomain: "exam-system-2ed90.firebaseapp.com",
    projectId: "exam-system-2ed90",
    storageBucket: "exam-system-2ed90.appspot.com",
    messagingSenderId: "576581410555",
    appId: "1:576581410555:web:e38cea3f14d10e5daa5a5e",
    measurementId: "G-BCFKVMVTBE"
  };

  const app = initializeApp(firebaseConfig);
  window.db = getFirestore(app);
  window.storage = getStorage(app);

  // ✅ Expose Firestore helpers globally
  window.setDoc = setDoc;
  window.getDoc = getDoc;
  window.getDocs = getDocs;
  window.doc = doc;
  window.collection = collection;
  /* ------------------------
   Announcements (Admin -> All users)
   ------------------------ */

// helper: clear textarea
function clearAnnouncementBox(){ $('#adminAnnText').value = ''; }

// Send announcement to Firestore (timestamp-id to keep ordering)
async function sendAnnouncement(){
  const text = ($('#adminAnnText').value || '').trim();
  if(!text) return alert('Enter a message to send.');
  try {
    const author = (window.currentAdmin || window.ADMIN_NAME || 'admin');
    const id = String(Date.now()) + '-' + Math.random().toString(36).slice(2,8);
    const payload = {
      text,
      author,
      createdAt: Date.now(),
      deleted: false
    };
    await setDoc(doc(db, "announcements", id), payload);
    $('#adminAnnText').value = '';
    alert('✅ Announcement sent.');
  } catch (err) {
    console.error('Failed to send announcement:', err);
    alert('❌ Failed to send (see console).');
  }
}

// Soft-delete (admin) — mark announcement deleted so it won't be shown to students
async function deleteAnnouncement(id){
  if(!confirm('Delete this announcement?')) return;
  try {
    await setDoc(doc(db, "announcements", id), { deleted: true, deletedAt: Date.now() }, { merge: true });
    alert('Deleted.');
  } catch (err) {
    console.error('deleteAnnouncement error', err);
    alert('Failed to delete (see console).');
  }
}

// Admin: render live announcement list (real-time)
function renderAdminAnnouncementsLive(){
  try {
    const colRef = collection(db, "announcements");
    // real-time updates
    onSnapshot(colRef, snap => {
      const out = $('#adminAnnList');
      out.innerHTML = '';
      // build array to sort by createdAt desc
      const arr = [];
      snap.forEach(d => {
        const data = d.data();
        if(!data) return;
        arr.push({ id: d.id, ...data });
      });
      arr.sort((a,b) => (b.createdAt||0) - (a.createdAt||0));
      if(arr.length === 0){
        out.innerHTML = '<div class="small">No announcements yet.</div>';
        return;
      }
      arr.forEach(a => {
        const wrapper = document.createElement('div');
        wrapper.className = 'list-item';
        wrapper.style.display = 'flex';
        wrapper.style.alignItems = 'center';
        wrapper.style.justifyContent = 'space-between';
        wrapper.innerHTML = `
          <div style="flex:1">
            <div style="font-weight:700">${escapeHTML(a.author || 'admin')} <span style="font-weight:400;font-size:12px;color:var(--muted)"> • ${new Date(a.createdAt).toLocaleString()}</span></div>
            <div style="margin-top:6px">${escapeHTML(a.text || '')}</div>
            ${a.deleted ? '<div style="color:var(--danger);font-size:12px;margin-top:4px">Deleted</div>' : ''}
          </div>
          <div style="margin-left:8px;white-space:nowrap">
            ${a.deleted ? '' : `<button class="btn" onclick="deleteAnnouncement('${a.id}')">Delete</button>`}
          </div>
        `;
        out.appendChild(wrapper);
      });
    });
  } catch (e) {
    console.warn('renderAdminAnnouncementsLive error', e);
  }
}

// Student-side: listen for the latest announcement and update top banner in real-time
// helper: normalize Firestore timestamp (returns milliseconds number)
function _normalizeTs(ts){
  if (!ts) return 0;
  if (typeof ts.toMillis === 'function') return ts.toMillis();
  if (ts.seconds) return Number(ts.seconds) * 1000;
  const n = Number(ts);
  return isNaN(n) ? 0 : n;
}

// helper to update home page banner (create minimal animation)
function updateHomeAnnouncement(msg){
  const el = document.getElementById('homeAnnouncement');
  if(!el) return;
  if(msg && msg.length){
    el.textContent = msg;
    el.style.display = 'block';
    el.style.transition = 'transform 220ms ease, background 300ms ease, opacity 220ms ease';
    el.style.transform = 'scale(1.01)';
    el.style.opacity = '1';
    setTimeout(()=> el.style.transform = 'scale(1)', 220);
  } else {
    el.style.opacity = '0';
    setTimeout(()=> { if(el) el.style.display = 'none'; }, 240);
  }
}

function startAnnouncementsListenerForStudents(){
  try {
    const colRef = collection(db, "announcements");
    onSnapshot(colRef, snap => {
      let latest = null;
      snap.forEach(d => {
        const data = d.data();
        if(!data) return;
        if(data.deleted) return; // ignore deleted

        const createdNum = _normalizeTs(data.createdAt);
        if(!latest || createdNum > (latest._createdAtNum || 0)) {
          latest = { id: d.id, ...data, _createdAtNum: createdNum };
        }
      });

      if(latest && latest.text) {
        // Update existing top banner text
        const banner = document.getElementById('examMsg');
        if(banner) {
          banner.textContent = latest.text;
          // small pulse animation: briefly change background to highlight
          banner.style.transition = 'background 300ms ease';
          banner.style.background = '#1f2937';
          setTimeout(()=> banner.style.background = '', 800);
        } else {
          // fallback: create a quick banner with existing helper if available
          if(typeof showAnnouncement === 'function'){
            showAnnouncement(latest.text);
          } else {
            console.log('Announcement:', latest.text);
          }
        }

        // Also update the home/sign-in banner (if present)
        updateHomeAnnouncement(latest.text);
      } else {
        // No valid latest announcement found — hide home banner if present
        updateHomeAnnouncement('');
      }
    });
  } catch (err) {
    console.warn('startAnnouncementsListenerForStudents error:', err);
  }
}


// small helper used in fallback (if present in your file)
function showAnnouncement(msg){
  const el = document.getElementById('examMsg');
  if(el) { el.textContent = msg; return; }
  // fallback: prepend simple banner
  let banner = document.getElementById('examMsg');
  if(!banner) {
    banner = document.createElement('div');
    banner.id = 'examMsg';
    banner.style.cssText = 'width:100%;padding:8px;text-align:center;font-weight:bold;background:#222;color:#fff;position:fixed;top:0;left:0;z-index:99999';
    document.body.prepend(banner);
  }
  banner.textContent = msg;
}

/* Start listeners where appropriate:
   - Call renderAdminAnnouncementsLive() once after admin login (or on admin page load)
   - Call startAnnouncementsListenerForStudents() during app init (so students get messages)
*/

// e.g. call when admin panel is shown
window.renderAdminAnnouncementsLive = renderAdminAnnouncementsLive;
window.startAnnouncementsListenerForStudents = startAnnouncementsListenerForStudents;
  
// --- expose announcement functions to global scope ---
window.sendAnnouncement = sendAnnouncement;
window.clearAnnouncementBox = clearAnnouncementBox;
window.deleteAnnouncement = deleteAnnouncement;
window.renderAdminAnnouncementsLive = renderAdminAnnouncementsLive;
window.startAnnouncementsListenerForStudents = startAnnouncementsListenerForStudents;
</script>


<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Online MCQ Examination Sytem </title>
<style>
#fsQuestion div {
  margin: 0;     /* remove default div margins */
  padding: 0;    /* no extra space */
}
.admin-question-text {
  white-space: pre-wrap;   /* preserve newlines & spaces */
  word-wrap: break-word;   /* wrap long words */
  margin-top: 4px;
  display: block;
}
.admin-question-text {
  white-space: pre-wrap;
  word-wrap: break-word;
}
#fsQuestion {
   max-height: 40vh;  /* reduce box height */
  overflow-y: auto;
  padding: 2px 6px;    /* less inner space */
  margin-bottom: 8px;  /* less gap below */
  border-radius: 6px;
  background: transparent;
  color: #e6eef8;
  white-space: pre-wrap;
}
.exam-message {
position: fixed;     /* stick to top */
  top: 0;
  left: 0;
  width: 100%;
  overflow: hidden;
  background: #002b5c;
  color: #fff;
  padding: 8px 0;
  font-weight: bold;
  text-align: center;
  border-radius: 0 0 6px 6px;
  margin-bottom: 10px;
}

#examMsg {
  display: inline-block;
  font-size: 16px;
  animation: colorChange 3s infinite alternate;
}

@keyframes colorChange {
  0%   { color: #ffeb3b; }  /* yellow */
  25%  { color: #4caf50; }  /* green */
  50%  { color: #03a9f4; }  /* blue */
  75%  { color: #e91e63; }  /* pink */
  100% { color: #ff5722; }  /* orange */
}
#examInner {
  margin-top: 40px;
}
 :root{
    --bg:#071428; --panel:#0b1a2b; --muted:#9aa6b2; --text:#e6eef8;
    --brand:#60a5fa; --good:#34d399; --danger:#f87171;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:var(--text);background:linear-gradient(180deg,#061026,#071428)}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  .header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:14px}
  .brand{font-weight:800;font-size:20px}
  .hint{color:var(--muted);font-size:13px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 14px 30px rgba(0,0,0,0.5)}
  .row{display:flex;gap:10px;align-items:center}
  .spacer{flex:1}
  label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
  input[type="text"], input[type="password"], input[type="number"], textarea, select { width:100%; padding:8px; border-radius:8px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); }
  textarea{
min-height:80px
 resize: vertical;
  padding: 8px;
  line-height: 1.4;
  vertical-align: top;
  text-align: left;}
  .btn{border:0;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:800}
  .btn.brand{background:var(--brand);color:#042033}
  .btn.warn{background:var(--good);color:#042033}
  .btn.danger{background:var(--danger);color:white}
  .small{font-size:12px;color:var(--muted)}
  .hidden{display:none!important}
  .list { max-height:320px; overflow:auto; margin-top:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); padding:8px }
  .list-item{ padding:8px; border-bottom:1px solid rgba(255,255,255,0.02); display:flex; gap:8px; align-items:center; }
  .badge{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02); color:var(--muted); font-weight:700; font-size:12px}
  /* Fullscreen exam */
  #examFullscreen{position:fixed;inset:0;background:linear-gradient(180deg,#041022,#041b2a);display:none;align-items:center;justify-content:center;z-index:9999;padding:20px}
  #examInner{width:min(1100px,96%);background:linear-gradient(180deg,#061426,#07182a);border-radius:14px;padding:22px;display:flex;gap:20px;align-items:flex-start;box-shadow:0 30px 80px rgba(0,0,0,0.6)}
  #fsUser{flex:0 0 220px;text-align:center}
  #fsUser img{width:160px;height:160px;border-radius:50%;object-fit:cover;border:4px solid rgba(255,255,255,0.04)}
  #fsUser h2{margin:12px 0 6px;font-size:20px}
  #fsMain {
  flex: 1;
  min-width: 320px;
  display: flex;
  flex-direction: column;
  max-height: 70vh; /* limit height on small screens */
}
#fsQuestion, #fsOptions {
  flex-shrink: 0;
}
#fsScrollArea {
  flex: 1;
  overflow-y: auto;   /* only this part scrolls */
  margin-bottom: 8px;
}
  .fsQuestion{font-size:20px;font-weight:700;margin-bottom:14px}
  .fsOptions{display:grid;gap:10px}
  .fsOpt{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;display:flex;gap:10px;align-items:center}
  .fsOpt.selected{outline:3px solid white;background:linear-gradient(90deg,rgba(96,165,250,0.04),transparent)}

.fsFooter {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: #07182a;
  position: sticky;
  bottom: 0;
  z-index: 20;
}

  .timer{font-weight:900;font-variant-numeric:tabular-nums}
  .progress-bar{width:100%;background:rgba(255,255,255,0.03);height:18px;border-radius:999px;margin-top:12px;overflow:hidden}
  .progress-fill{height:100%;background:linear-gradient(90deg,#34d399,#60a5fa);width:0%;transition:width 800ms ease}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
  th{background:rgba(255,255,255,0.02)}
  /* responsive */
  @media (max-width:900px){
    #examInner{flex-direction:column;align-items:center}
    #fsUser{order:1}
    #fsMain{order:2;width:100%}
  }
.userPhoto {
  width: 80px;
  height: 80px;
  object-fit: cover;
  border-radius: 8px;
}
  #examCharacter {
  position: fixed;
  top: 50px;
  left: 50px;
  width: 60px;       /* size of your character */
  height: 60px;
  pointer-events: none; /* so it won’t block clicks */
  transition: transform 0.1s linear; /* smooth movement */
  z-index: 9999;
}
.answer-stats {
  margin-top: 6px;
  font-size: 14px;
  color: var(--muted);
  text-align: center;
}
.answer-stats span {
  margin: 0 8px;
}

@media (max-width:600px){
  body { font-size: 14px; }
  .brand { font-size: 16px; }
  h3 { font-size: 16px; }
  .btn { padding: 6px 10px; font-size: 14px; }
}
@media (max-width:600px){
  .btn { width: 100%; margin-bottom: 6px; }
  .row { flex-direction: column; align-items: stretch; }
}
@media (max-width:600px){
  #fsUser img { width: 100px; height: 100px; }
}
/* Compact grid of question numbers on mobile */
@media (max-width:600px){
  #questionNav {
    display: grid !important;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); 
    gap: 6px;
    padding: 8px 4px;
  }
  #questionNav button {
    min-width: 40px;
    height: 40px;
    font-size: 14px;
    text-align: center;
    border-radius: 6px; /* square with rounded edges */
    padding: 0;
  }
}

</style>
</head>
<body>
  <!-- ========== HOME / SIGN IN PAGE (NEW) ========== -->
<section id="home" style="position:fixed;inset:0;background:#3b78b5;display:flex;align-items:center;justify-content:center;z-index:9998;">
  <button id="homeAdminBtn" style="position:fixed;top:28px;right:34px;padding:10px 18px;border-radius:8px;border:2px solid rgba(255,255,255,0.85);background:transparent;color:white;font-weight:700;cursor:pointer;z-index:10000;">
    Admin
  </button>

  <div style="width:720px;max-width:92vw;border-radius:10px;padding:36px 40px 46px;box-sizing:border-box;
              background:linear-gradient(180deg,#3fb1d9 0%,#2b62a3 100%);border:2px solid rgba(255,255,255,0.6);
              box-shadow:0 30px 70px rgba(0,0,0,0.25);text-align:center;color:rgba(255,255,255,0.95);">
    <div style="width:86px;height:86px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;margin:6px auto 10px;border:3px solid rgba(255,255,255,0.6);background: rgba(255,255,255,0.06);">
      <!-- user icon -->
      <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" style="width:46px;height:46px;opacity:0.95">
        <circle cx="32" cy="24" r="12" fill="white" fill-opacity="0.95" />
        <path d="M10 54c0-10 12-18 22-18s22 8 22 18" fill="white" fill-opacity="0.95" />
      </svg>
    </div>

    <h1 style="margin:8px 0 24px;font-weight:400;font-size:34px;letter-spacing:1px">Sign in</h1>

    <div style="width:100%;max-width:560px;margin:6px auto;display:flex;align-items:center;gap:12px;padding:10px 6px;border-bottom:1px solid rgba(255,255,255,0.6);">
      <div style="width:30px;opacity:0.85;">
        <!-- username icon -->
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
      </div>
      <input id="homeUsername" type="text" placeholder="Username" style="flex:1;background:transparent;border:0;outline:none;padding:10px 6px;color:rgba(255,255,255,0.95);font-size:16px" />
    </div>

    <div style="width:100%;max-width:560px;margin:18px auto 0;display:flex;align-items:center;gap:12px;padding:10px 6px;border-bottom:1px solid rgba(255,255,255,0.6);">
      <div style="width:30px;opacity:0.85;">
        <!-- password icon -->
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
      </div>
      <input id="homePassword" type="password" placeholder="Password" style="flex:1;background:transparent;border:0;outline:none;padding:10px 6px;color:rgba(255,255,255,0.95);font-size:16px" />
    </div>

    <div style="margin-top:22px">
      <button id="homeLoginBtn" style="background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.06)); border:2px solid rgba(255,255,255,0.85); padding:12px 36px; border-radius:8px; font-size:18px; font-weight:600; cursor:pointer;">
        Login
      </button>
      <!-- paste inside <section id="home"> somewhere near the top -->
<div id="homeAnnouncement"
     style="display:none; z-index:10002; max-width:1100px; margin:12px auto 0; padding:8px 12px;
            background:#072b4a; color:#fff; text-align:center; border-radius:8px; font-weight:700;">
</div>
      <div style="font-size:13px;opacity:0.9;margin-top:8px">Made by Ranjan Ray.</div>
    </div>
  </div>
</section>
<!-- ========== END HOME ========== -->

<div class="wrap card">
  <div class="header">
    <div>
      <div class="brand" id="examHeader">
  <!-- filled by JS -->
</div>

      <div class="hint">Offline • localStorage • Import/Export • Admin results</div>
    </div>
    <div class="row">
      <button class="btn brand" onclick="showSection('user')">User</button>
      <button class="btn" onclick="showSection('adminLogin')">Admin Login</button>
    </div>
  </div>

  <!-- USER SECTION -->
  <section id="user">
    <div class="card">
      <h3>User Login / Register</h3>
      <div class="row" style="gap:12px">
        <div style="flex:1">
          <label>Username</label>
          <input id="userName" class="input" type="text" placeholder="username (e.g. rahul)">
        </div>
        <div style="width:220px">
          <label>Photo (first-time)</label>
          <input id="userPhoto" type="file" accept="image/*">
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Password</label>
          <input id="userPass" type="password">
        </div>
        <div style="width:160px;align-self:end">
          <button class="btn brand" onclick="handleUserLogin()">Login / Register</button>
        </div>
      </div>
      <div class="small" style="margin-top:8px">If username exists, enter the same password to login. New users must upload photo to register.</div>
    </div>

        <div style="height:12px"></div>
    <!-- Quick import/export hidden from user view (moved to admin) -->
    <div class="card hidden" id="quickImportCard">
      <h3>Quick Import / Export</h3>
      <div class="row">
        <button class="btn" onclick="triggerImportUsers()">Import Users (.json)</button>
        <button class="btn" onclick="triggerImportQuestions()">Import Questions (.json)</button>
        <div class="spacer"></div>
        <button class="btn" onclick="exportUsers()">Export Users (.json)</button>
        <button class="btn" onclick="exportQuestions()">Export Questions (.json)</button>
      </div>
      <div class="small" style="margin-top:8px">App auto-loads previously stored users & questions on page load.</div>
    </div>

  </section>

  <!-- IMPORT / EXPORT -->
  <section id="import" class="hidden">
    <div class="card">
      <h3>Import / Export</h3>
      <div class="row">
        <div style="flex:1">
          <label>Import Users (JSON file with array of {username,password,photo})</label>
          <input id="impUsersFile" type="file" accept="application/json" onchange="importUsersFile(event)">
        </div>
        <div style="width:220px">
          <label>Import Questions (.json)</label>
          <input id="impQFile" type="file" accept="application/json" onchange="importQuestionsFile(event)">
        </div>
      </div>
<div style="height:12px"></div>
<div class="row">
  <button class="btn" onclick="exportSettings()">Export Exam Settings (.json)</button>
  <button class="btn" onclick="triggerImportSettings()">Import Exam Settings (.json)</button>
  <input id="impSettingsFile" type="file" accept="application/json" onchange="importSettingsFile(event)" style="display:none">
</div>

      <div style="height:12px"></div>
    <div class="row">
  <button class="btn" onclick="exportUsers()">Export Users (.json)</button>
  <button class="btn" onclick="exportQuestions()">Export Questions (.json)</button>
  <div class="spacer"></div>
  <button class="btn warn" onclick="downloadBackup()">Download Full Backup (.json)</button>
  <button class="btn" onclick="updateBackup()">Update Full Backup</button> <!-- ✅ new -->
</div>


<div class="row" style="margin-top:10px">
  <label class="btn">
    Import Full Backup (.json)
    <input type="file" id="importBackupFile" accept="application/json"
           style="display:none"
           onchange="importFullBackup(this.files[0])">
  </label>
</div>

<div class="small" style="margin-top:8px">
  Photos must be base64 data URLs in the users JSON to be portable (we export that way).
</div>
</section>

  <!-- ADMIN LOGIN -->
  <section id="adminLogin" class="hidden">
    <div class="card">
      <h3>Admin Login</h3>
      <label>Admin password</label>
      <input id="adminPass" type="password" value="">
      <div class="row" style="margin-top:10px">
        <button class="btn brand" onclick="handleAdminLogin()">Login</button>
        <div class="spacer"></div>
        <div class="small">Made by: <b>Ranjan Kumar</b></div>
      </div>
    </div>
  </section>

  <!-- ADMIN PANEL (visible after login) -->
<section id="adminPanel" class="hidden">
<!-- add this inside adminPanel, e.g. right after <section id="adminPanel"...> -->
<div style="margin-bottom:10px;">
  <button class="btn" onclick="showSection('import')">Import / Export (Admin)</button>
</div>

  <!-- Exam Settings Card -->
<button onclick="resetSettings()">🔄 Reset Settings</button>
<label>Logo</label>
<input id="adminLogo" type="file" accept="image/*">
<img id="logoPreview" style="max-height: 80px; display:none;" alt="Logo preview">


<label>Author</label>
<input id="adminAuthor" type="text" placeholder="e.g. Ranjan Kumar">

<label>College Name</label>
<input id="adminCollege" type="text" placeholder="e.g. Regional College of Pharmaceutical Sciences">

<label>Subject</label>
<input id="adminSubject" type="text" placeholder="e.g. Computer Applications in Pharmacy">

<label>Subject Code</label>
<input id="adminSubjectCode" type="text" placeholder="e.g. BP210P">

<label>Full Marks</label>
<input id="adminFullMarks" type="number" min="0" placeholder="e.g. 20">

<label style="margin-top:8px">Synopsis Questions</label>
<input id="adminCountSynopsis" type="number" min="0" value="2" oninput="updateQuestionPreview()"/>

<label style="margin-top:8px">Minor Practical Questions</label>
<input id="adminCountMinor" type="number" min="0" value="2" oninput="updateQuestionPreview()"/>

<label style="margin-top:8px">Major Practical Questions</label>
<input id="adminCountMajor" type="number" min="0" value="1" oninput="updateQuestionPreview()"/>

<label style="margin-top:8px">Viva Questions</label>
<input id="adminCountViva" type="number" min="0" value="2" oninput="updateQuestionPreview()"/>


<div id="questionPreview" class="small" style="margin-top:8px; font-weight:bold; color:#2563eb;">
  Total Questions: 0
</div>

  <div class="card">
    <h3>Exam Settings</h3>
<!-- Resume controls -->
<label style="margin-top:8px">
  <input type="checkbox" id="adminResumeEnabled"> Enable Resume (allow users to resume after refresh/close)
</label>

<label style="margin-top:8px">
  Max Resume / Refreshes allowed per user
</label>
<input id="adminMaxResumes" type="number" min="0" value="2"/>

<div class="small" style="margin-top:6px">
  When resume is enabled, the system saves session state periodically and allows users to resume. If a user refreshes/closes more than the allowed number, further starts/resumes are blocked.
</div>
    <label>Exam Duration (minutes)</label>
<label style="margin-top:8px">Number of Questions</label>
<label style="margin-top:8px">
  <input type="checkbox" id="adminShuffle"> Shuffle Questions
</label>
<label style="margin-top:8px">
  <input type="checkbox" id="adminAllowAfterTime"> Allow answering after time ends
</label>

<input id="adminTotalQs" type="number" min="1" value="10"/>
    <input id="adminDuration" type="number" min="1" value="30"/>
<label style="margin-top:8px">Custom Exam Message</label>
  <input id="adminCustomMsg" type="text" value="📢 Welcome to your exam! Stay calm, focus, and do your best, Made by Ranjan Kumar 🚀"/>
    <div class="row" style="margin-top:8px">
      <button class="btn brand" onclick="saveExamSettings()">Save Settings</button>
    </div>
    <div class="small">This duration will apply to all new exams.</div>
  </div>

  <div style="height:12px"></div>

  <!-- Question Bank Card -->
  <div class="card">
    <div class="row" style="align-items:flex-start">
      <div style="flex:1">
        <h3>Question Bank — Add / Edit</h3>
        <label>Category</label>
        <select id="qCategory">
          <option>Synopsis</option>
          <option>Minor Practical</option>
          <option>Major Practical</option>
          <option>Viva</option>
        </select>
        <label style="margin-top:8px">Question</label>
        <textarea id="qText"></textarea>
        <label>Option A</label><input id="qA" type="text"/>
        <label>Option B</label><input id="qB" type="text"/>
        <label>Option C</label><input id="qC" type="text"/>
        <label>Option D</label><input id="qD" type="text"/>
        <div class="row" style="margin-top:8px;align-items:center">
          <div style="width:160px">
            <label>Correct answer</label>
            <select id="qAnswer">
              <option value="0">A</option>
              <option value="1">B</option>
              <option value="2">C</option>
              <option value="3">D</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Marks</label>
            <input id="qMarks" type="number" min="1" value="1"/>
          </div>
          <div class="spacer"></div>
          <button class="btn brand" onclick="saveQuestion()">Save</button>
          <button class="btn danger" onclick="cancelEdit()">Cancel</button>
        </div>
      </div>

      <div style="width:420px;min-width:280px">
        <h3>Questions</h3>
        <div id="questionsList" class="list"></div>
        <div style="margin-top:8px" class="row">
          <button class="btn" onclick="exportQuestions()">Export questions (.json)</button>
          <button class="btn danger" onclick="clearAllQuestions()">Delete All</button>
        </div>
      </div>
    </div>
  </div>

  <div style="height:12px"></div>

  <!-- Users Card -->
  <div class="card">
    <h3>Users</h3>
    <div class="row">
      <div style="flex:1">
        <label>Username</label><input id="adminNewUser" type="text"/>
<label>Full Name</label><input id="adminNewFull" type="text"/>
        <label>Password</label><input id="adminNewPass" type="text"/>
        <label>Photo</label><input id="adminNewPhoto" type="file" accept="image/*"/>
        <div class="row" style="margin-top:8px">
          <button class="btn brand" onclick="adminCreateUser()">Create / Update</button>
          <button class="btn danger" onclick="adminClearUsers()">Delete All Users</button>
        </div>
      </div>
      <div style="width:360px">
        <h4>Existing Users</h4>
        <div id="adminUsersList" class="list"></div>
      </div>
    </div>
  </div>

  <div style="height:12px"></div>

  <!-- Results Card -->
  <div class="card">
    <h3>Results</h3>
    <div class="row">
      <button class="btn" onclick="renderResults()">Refresh</button>
      <button class="btn" onclick="exportResultsJSON()">Export results (.json)</button>
      <button class="btn" onclick="triggerImportResults()">Import results (.json)</button>
      <button class="btn" onclick="exportResultsCSV()">Export results (.csv)</button>
      <div class="spacer"></div>
      <button class="btn danger" onclick="clearResults()">Clear Results</button>
    </div>
    <input id="impResultsFile" type="file" accept="application/json" multiple onchange="importResultsFile(event)" style="display:none">
    <div id="resultsArea" style="margin-top:10px; max-height:360px; overflow:auto"></div>
  </div>
<!-- Announcements / Live Chat (Admin → All users) -->
<div class="card" id="adminAnnouncementsCard" style="margin-top:12px; display:block;">
  <h3>Announcements — Broadcast to all students</h3>
  <label>Write announcement</label>
  <textarea id="adminAnnText" placeholder="Type message to broadcast (short)"></textarea>
  <div class="row" style="margin-top:8px">
    <button class="btn brand" onclick="sendAnnouncement()">Send to all</button>
    <button class="btn" onclick="clearAnnouncementBox()">Clear</button>
    <div class="spacer"></div>
    <div class="small">Messages appear in students' top banner instantly.</div>
  </div>

  <div style="height:8px"></div>
  <label>Recent announcements</label>
  <div id="adminAnnList" class="list" style="max-height:180px; overflow:auto">
    <div class="small">No announcements yet.</div>
  </div>
</div>
<div class="card" id="adminVisitorsCard" style="margin-top:12px;">
  <h3>Visitors (before login)</h3>
  <button class="btn" onclick="renderVisitorsAdmin()">Refresh</button>
  <div id="adminVisitorsList" class="list" style="margin-top:10px; max-height:260px; overflow:auto">
    <div class="small">No visitors yet.</div>
  </div>
</div>
</section>
<!-- Live Sessions (Admin) -->
<div class="card" id="adminSessionsCard" style="margin-top:12px; display:none">
  <h3>Live Sessions — Who is giving exam?</h3>
  <div class="row" style="gap:8px;align-items:center">
    <button class="btn" onclick="renderSessionsAdmin()">Refresh</button>
    <label style="margin-left:8px">
      <input type="checkbox" id="adminAutoRefreshSessions"> Auto-refresh every 5s
    </label>
    <div class="spacer"></div>
    <button class="btn danger" onclick="clearAllSessions()">Clear All Sessions</button>
  </div>

  <div id="adminSessionsList" class="list" style="margin-top:10px; max-height:320px; overflow:auto">
    <!-- Filled by JS -->
    <div class="small">No sessions loaded. Click Refresh.</div>
  </div>
  <div class="small" style="margin-top:8px">Shows active/persisted session state saved in Firestore 'sessions' collection.</div>
</div>


  <div style="height:12px"></div>
  <div class="small">Tip: All data stored locally in this browser. Use export/import to move data between machines.</div>
</div>

<!-- Fullscreen exam -->
<div id="examFullscreen">
<!-- Instructions Overlay -->
<div id="examInstructionsOverlay" 
     style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; 
            background:rgba(0,0,0,0.9); z-index:10000;">
  <div style="max-width:700px; background:#0b1a2b; padding:20px; border-radius:12px; 
              color:#e6eef8; text-align:left; box-shadow:0 0 25px rgba(0,0,0,0.6)">
    <h2 style="text-align:center; color:#60a5fa;">📘 Exam Instructions</h2>
    <ul style="margin-top:12px; line-height:1.6;">
      <li>✅ Stay in fullscreen mode during the exam. Exiting will pause the test.</li>
      <li>✅ Do not refresh or close the browser during the exam.</li>
      <li>✅ Use the navigation buttons to move between questions.</li>
      <li>✅ You may flag questions for review before submission.</li>
      <li>✅ Timer will count down automatically. Submit before time runs out.</li>
      <li>✅ Results will be shown immediately after submission.</li>
    </ul>
    <div style="text-align:center; margin-top:20px;">
      <button onclick="dismissInstructions()" 
              style="padding:10px 20px; font-size:16px; font-weight:bold; 
                     border-radius:10px; background:#34d399; color:#042033; cursor:pointer;">
        🚀 Start Exam
      </button>
    </div>
  </div>
</div>

  <!-- 🔹 Custom Animated Message (top banner) -->
  <div class="exam-message">
     <div id="examMsg">📢 Welcome to your exam! Best of luck 🚀 </div>
  </div>
<div id="examCharacterName" 
     style="
       position: absolute;
       font-size: 24px;
       font-weight: bold;
       color: #60a5fa;
       pointer-events: none;
       user-select: none;
       z-index: 9999;
     ">
</div>
<!-- 🔒 Lock screen when exam is paused -->
<div id="lockScreen"
     style="position:fixed;inset:0;background:rgba(0,0,0,0.85);
            color:white;display:none;flex-direction:column;align-items:center;
            justify-content:center;z-index:10000;">
  <h2>⚠️ Exam Paused</h2>
  <p>You exited fullscreen mode. Enter the password to continue.</p>
  <input type="password" id="unlockPassword" placeholder="Enter password"
         style="padding:8px;margin-top:10px">
  <button onclick="unlockExam()" 
          style="padding:8px 15px;margin-top:10px;cursor:pointer;">
    Unlock & Resume
  </button>
</div>

  <div id="examInner">
    <div id="fsUser">
      <img id="fsPhoto" src="" alt="photo">
      <h2 id="fsName"></h2>
      <div class="small" id="fsMeta"></div>
 <div id="answerStats" class="answer-stats"></div>
    </div>
    <div id="fsMain">
      <div id="fsScrollArea">
  <div id="fsQuestion">Question will appear here</div>
  <div id="fsOptions"></div>
</div>

      <!-- NEW: Direct question navigation -->
      <div id="questionNav" style="display:flex;flex-wrap:wrap;gap:6px;margin:12px 0;"></div>

      <div class="fsFooter">
        <div style="display:flex;gap:8px;">
          <button class="btn" onclick="toggleFlag()">⚑ Flag</button>
          <button class="btn" onclick="prevQuestion()">⟵ Prev</button>
          <button class="btn" onclick="nextQuestion()">Next ⟶</button>
        </div>
        <div class="spacer"></div>
        <div class="timer" id="fsTimer">00:00:00</div>
        <button class="btn warn" onclick="submitExam()">Submit</button>
      </div>
      <div class="progress-bar"><div class="progress-fill" id="fsProgressFill"></div></div>
    </div>
  </div>
<div id="answerStats" class="answer-stats"></div>

</div>


<script>
async function saveToFirestore(collectionName, id, data, localKey=null) {
  try {
    if (localKey) write(localKey, data); // keep offline copy
    await setDoc(doc(db, collectionName, id), data);
    console.log(`✅ Firestore saved: ${collectionName}/${id}`);
    return true;
  } catch (err) {
    console.warn("⚠️ Firestore save failed, local only", err);
    return false;
  }
}

/* -------------------------
   Storage keys & defaults
   ------------------------- */
const K_USERS = 'offline_mcq_users_v1';
const K_QS = 'offline_mcq_qs_v1';
const K_RESULTS = 'offline_mcq_results_v1';
const K_ADMIN = 'offline_mcq_admin_v1';

const MASTER_ADMIN = { username: 'admin', password: 'exam123' };
const K_SETTINGS = 'offline_mcq_settings_v1';

/* Helpers */
const $ = s => document.querySelector(s);
const $all = s => Array.from(document.querySelectorAll(s));
const uid = () => Math.random().toString(36).slice(2,9);
const read = (k,def) => { try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : def; } catch { return def; } }
const write = (k,v) => localStorage.setItem(k, JSON.stringify(v));
const download = (filename, content, type='text/plain') => {
  const blob = new Blob([content], {type});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
};
// Escape HTML to show tags as plain text
function escapeHTML(str) {
  return str.replace(/[&<>"']/g, m => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[m]));
}
// Text encoder/decoder
const enc = new TextEncoder();
const dec = new TextDecoder();

// Fixed secret key (you can also ask admin for password to generate this)
const SECRET_KEY = "exam-secret-key-123"; 

// Derive AES key from secret string
async function getKey() {
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(SECRET_KEY), { name: "PBKDF2" }, false, ["deriveKey"]
  );
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: enc.encode("exam-salt"), iterations: 1000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

async function encryptData(obj) {
  const key = await getKey();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = enc.encode(JSON.stringify(obj));
  const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
  return { iv: Array.from(iv), data: btoa(String.fromCharCode(...new Uint8Array(encrypted))) };
}

async function decryptData(encObj) {
  const key = await getKey();
  const iv = new Uint8Array(encObj.iv);
  const data = Uint8Array.from(atob(encObj.data), c => c.charCodeAt(0));
  const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
  return JSON.parse(dec.decode(decrypted));
}


/* Load or seed data */
let users = read(K_USERS, []);
let questions = read(K_QS, []);
let results = read(K_RESULTS, []);
let adminCred = read(K_ADMIN, null);
let settings = read(K_SETTINGS, { 
  durationMin: 20, 
  customMsg: "📢 Welcome to your exam! Stay calm, focus, and do your best!",
  shuffle: false,
  allowAfterTime: false,
  logo: "",            // ✅ no default logo
  author: "",          // ✅ blank
  college: "",         // ✅ blank
  subject: "",         // ✅ blank
  subjectCode: "",     // ✅ blank
  fullMarks: 0,        // ✅ blank
  counts: {
    Synopsis: 0,
    "Minor Practical": 0,
    "Major Practical": 0,
    Viva: 0
  }
});


if(!adminCred) write(K_ADMIN,
                     MASTER_ADMIN);

if(questions.length === 0){
  // seed sample questions
  questions = [
    { id: uid(), question: 'HTML stands for?', options: ['Hyperlinks Text Markup','Home Tool Markup','Hyper Text Markup Language','Hyperlinking Text Markdown'], answer: 2, marks: 1, category: 'Synopsis' },
    { id: uid(), question: 'Which tag defines paragraph?', options: ['<p>','<para>','<pg>','<par>'], answer: 0, marks: 1, category: 'Minor Practical' },
    { id: uid(), question: 'Which method adds to array end?', options: ['push','pop','shift','unshift'], answer: 0, marks: 2, category: 'Major Practical' },
    { id: uid(), question: 'Does localStorage persist after browser restart?', options: ['Yes','No','Sometimes','Depends'], answer: 0, marks: 1, category: 'Viva' }
  ];
  write(K_QS, questions);
}
function downloadBackup() {
  const backup = {
    users,
    questions,
    results,
    settings,
    adminCred
  };
  const blob = new Blob([JSON.stringify(backup, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "exam_full_backup.json";
  a.click();
}

function importFullBackup(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const backup = JSON.parse(e.target.result);

      users = backup.users || [];
      questions = backup.questions || [];
      results = backup.results || [];

      // Merge with defaults
      settings = {
        ...settings,
        durationMin: backup.settings?.durationMin ?? settings.durationMin ?? 30,
        customMsg: backup.settings?.customMsg ?? settings.customMsg ?? "📢 Welcome to your exam! Stay calm, focus, and do your best!",
        shuffle: backup.settings?.shuffle ?? settings.shuffle ?? false,
        allowAfterTime: backup.settings?.allowAfterTime ?? settings.allowAfterTime ?? false,
        logo: backup.settings?.logo ?? settings.logo ?? "",
        author: backup.settings?.author ?? settings.author ?? "",
        college: backup.settings?.college ?? settings.college ?? "",
        subject: backup.settings?.subject ?? settings.subject ?? "",
        subjectCode: backup.settings?.subjectCode ?? settings.subjectCode ?? "",
        fullMarks: backup.settings?.fullMarks ?? settings.fullMarks ?? 0,
        counts: {
          Synopsis: backup.settings?.counts?.Synopsis ?? settings.counts?.Synopsis ?? 0,
          "Minor Practical": backup.settings?.counts?.["Minor Practical"] ?? settings.counts?.["Minor Practical"] ?? 0,
          "Major Practical": backup.settings?.counts?.["Major Practical"] ?? settings.counts?.["Major Practical"] ?? 0,
          Viva: backup.settings?.counts?.Viva ?? settings.counts?.Viva ?? 0
        }
      };

      adminCred = backup.adminCred || MASTER_ADMIN;

      write(K_USERS, users);
      write(K_QS, questions);
      write(K_RESULTS, results);
      write(K_SETTINGS, settings);
      write(K_ADMIN, adminCred);

      alert("✅ Full backup restored!");
      renderUsersAdmin();
      renderQuestionsList();
      renderResults();
      renderSettingsAdmin();
    } catch (err) {
      alert("❌ Invalid backup file");
      console.error(err);
    }
  };
  reader.readAsText(file);
}


function updateBackup() {
  const backup = {
    users,
    questions,
    results,
    settings,
    adminCred
  };
  const blob = new Blob([JSON.stringify(backup, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "exam_full_backup.json"; // same name every time
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);

  alert("✅ Backup updated! Please replace the old file when saving.");
}

/* UI: show sections (updated to support 'home' fullscreen) */
function showSection(id){
  // hide the home view and app wrap by default
  const homeEl = document.getElementById('home');
  const wrapEl = document.querySelector('.wrap');

  if(id === 'home') {
    if(homeEl) homeEl.classList.remove('hidden');
    if(wrapEl) wrapEl.classList.add('hidden');
    return;
  }

  // show the main app wrap and hide home
  if(homeEl) homeEl.classList.add('hidden');
  if(wrapEl) wrapEl.classList.remove('hidden');

  // hide internal sections inside the app
  ['user','import','adminLogin','adminPanel'].forEach(s => { const el = document.getElementById(s); if(!el) return; el.classList.add('hidden'); });
  const target = document.getElementById(id);
  if(target) target.classList.remove('hidden');

  if(id === 'adminPanel') {
    renderQuestionsList();
    renderUsersAdmin();
    renderResults();
  }
}
// Wire home buttons to existing flows
document.addEventListener('DOMContentLoaded', ()=> {
  // Start the app showing the Home view
  if(typeof showSection === 'function') showSection('home');

  const adminBtn = document.getElementById('homeAdminBtn');
  if(adminBtn) adminBtn.addEventListener('click', ()=> showSection('adminLogin'));

  const loginBtn = document.getElementById('homeLoginBtn');
  if(loginBtn) loginBtn.addEventListener('click', async ()=> {
    // copy values from home inputs to the existing user form and call login
    const u = document.getElementById('homeUsername').value.trim();
    const p = document.getElementById('homePassword').value;
    if(!u || !p) return alert('Enter username and password');

    // fill the existing user form so all logic (photo, resume checks) works as before
    document.getElementById('userName').value = u;
    document.getElementById('userPass').value = p;

    // show user section (so any UI messages appear), then call your existing handler
    showSection('user');

    // call the existing user login handler (if you use the resume version, call that instead)
    if(typeof handleUserLogin === 'function') {
      // small delay so UI switches before heavy work
      setTimeout(()=> handleUserLogin(), 120);
    } else if(typeof handleUserLogin_withResume === 'function') {
      setTimeout(()=> handleUserLogin_withResume(), 120);
    } else {
      alert('Login handler not found – ensure handleUserLogin exists.');
    }
  });

  // Enter key on home password should trigger login
  document.getElementById('homePassword').addEventListener('keydown', (e)=>{ if(e.key === 'Enter') document.getElementById('homeLoginBtn').click(); });
});


/* ---------- USER FLOW ---------- */

/* convert File -> base64 data URL */
function fileToDataURL(file){ return new Promise(res => { const fr = new FileReader(); fr.onload = ()=> res(fr.result); fr.readAsDataURL(file); }); }

/* handle login/register */
async function handleUserLogin_withResume(){
  const username = $('#userName').value.trim();
  const pass = $('#userPass').value;
  const file = document.getElementById('userPhoto').files[0];

  if(!username || !pass) return alert('Enter username and password');

  let user = users.find(u => u.username === username && u.password === pass);
  if(!user){
    if(!file) return alert('New user: upload photo to register');
    const photo = await fileToDataURL(file);
    const fullName = username;
    user = { username, password: pass, photo, fullName };
    users.push(user);
    saveToFirestore("users", user.username, user);
  }

  // ❗ Block users who already attempted
  const arr = await getResultsArray();
  if (arr.some(r => r.username === username)) {
    alert(`⚠️ "${username}" has already attempted the exam.`);
    return; // stop here, don’t load settings or start exam
  }

  // ✅ Ensure latest settings (with durationMin) are in memory
  await loadSettingsFromFirestore();

  // Start the exam
  startExam(user);
}

async function getResultsArray() {
  // If memory already has a usable array, return it
  if (Array.isArray(results)) return results;

  // Try localStorage (encrypted)
  const stored = read(K_RESULTS, null);
  if (stored) {
    try {
      const arr = await decryptData(stored);
      if (Array.isArray(arr)) {
        results = arr;       // keep in memory as array
        return results;
      }
    } catch (e) {
      console.warn("Could not decrypt local results", e);
    }
  }

  // Try Firestore (encrypted bundle at results/all)
  try {
    const snap = await getDoc(doc(db, "results", "all"));
    if (snap.exists()) {
      const enc = snap.data().data;
      const arr = await decryptData(enc);
      if (Array.isArray(arr)) {
        results = arr;
        return results;
      }
    }
  } catch (e) {
    console.warn("Could not load results from Firestore", e);
  }

  // Fallback: empty
  results = [];
  return results;
}

/* ---------------- EXAM RUNTIME (fullscreen) ---------------- */

let EXAM = {
  paper: [],      // array of questions (copied)
  state: null,    // {username,answers:{qId:choice},flags:{qId:true},startedAt,remainingMs,submitted}
  timerId: null,
  cur: 0,
  cfg: { durationMin: 30, total: null, shuffle: false } // default
};

function buildPaper(qbank, shuffle){
  let selected = [];

  // group by category
  const byCategory = {
    Synopsis: qbank.filter(q => q.category === "Synopsis"),
    "Minor Practical": qbank.filter(q => q.category === "Minor Practical"),
    "Major Practical": qbank.filter(q => q.category === "Major Practical"),
    Viva: qbank.filter(q => q.category === "Viva")
  };

  // helper to pick random questions
  function pickRandom(arr, count){
    const copy = arr.slice();
    const chosen = [];
    for (let i = 0; i < count && copy.length > 0; i++) {
      const idx = Math.floor(Math.random() * copy.length);
      chosen.push(copy.splice(idx,1)[0]);
    }
    return chosen;
  }

  // pick based on settings.counts
  for (let cat in settings.counts){
    if (byCategory[cat]) {
      selected = selected.concat(pickRandom(byCategory[cat], settings.counts[cat]));
    }
  }

  // shuffle overall exam if enabled
  if (shuffle) {
    for (let i = selected.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [selected[i], selected[j]] = [selected[j], selected[i]];
    }
  }

  return selected.map(q => ({
    id: q.id,
    question: q.question,
    options: q.options,
    answer: q.answer,
    marks: q.marks,
    category: q.category
  }));
}

async function startExam(user){
  enterFullscreen(document.documentElement); // force fullscreen

  // --- Use Firestore settings as source of truth
  EXAM.cfg.total   = settings.totalQs || questions.length;
  EXAM.cfg.shuffle = !!settings.shuffle;
  const durationMin = Number(settings.durationMin ?? 30);
  EXAM.cfg.durationMin = durationMin;

  console.log(`⏳ Starting exam with duration: ${EXAM.cfg.durationMin} minutes`);

  document.getElementById("examMsg").textContent = settings.customMsg || "";
  document.getElementById("examCharacterName").textContent = user.fullName || user.username;

  EXAM.paper = buildPaper(questions, EXAM.cfg.shuffle);

  const durationMs = Math.max(1, durationMin) * 60_000;

  // Fresh exam state: everyone starts with the SAME duration
  EXAM.state = {
    username: user.username,
    answers: {},
    flags: {},
    startedAt: Date.now(),
    durationMs: durationMs,
    remainingMs: durationMs,  // ← set baseline
    submitted: false
  };
  EXAM.cur = 0;

  // --- Optional resume logic (only if you WANT it)
  // Add a checkbox in admin to set settings.resumeEnabled if you need this behavior.
  if (settings.resumeEnabled === true) {
    const resume = await loadTimer(user.username); // should return { remainingMs } or null
    if (resume && typeof resume.remainingMs === "number") {
      // Clamp to [0, durationMs] to avoid weird values
      const clamped = Math.min(Math.max(0, resume.remainingMs), durationMs);
      if (clamped > 0 && clamped < durationMs) {
        EXAM.state.remainingMs = clamped;
        console.log(`↩ Resuming with ${Math.round(clamped/60000)} min left`);
      }
    }
  }

  // Show fullscreen modal
  $('#examFullscreen').style.display = 'flex';
  $('#fsPhoto').src = user.photo || '';
  $('#fsName').textContent = user.fullName || user.username;

  paintQuestion();
  startTimer(); // uses EXAM.state.remainingMs
await saveSessionToFirestore(user.username, EXAM.state, EXAM.paper);
startPeriodicSessionSave();
}

async function loadTimer(username) {
  try {
    const snap = await getDoc(doc(db, "timers", username));
    if (snap.exists()) {
      const saved = snap.data();
      if (EXAM.state) {
        EXAM.state.remainingMs = saved.remainingMs;
      }
      console.log("⏳ Restored timer for", username, saved.remainingMs);
    }
  } catch (err) {
    console.error("⚠️ Failed to load timer:", err);
  }
}

/* ----------------------------
   Resume & refresh/close limit
   ---------------------------- */

/*
  sessions/{username} doc shape:
  {
    remainingMs: Number,
    updatedAt: Number,
    resumes: Number,        // number of times the user closed/refresh-resumed
    startedAt: Number,
    cur: Number,
    paperIds: [qId,...],
    answers: { qId: choice, ... },
    flags: { qId:true, ... }
  }
*/

// Save session state to Firestore (merge)
// helper: get public IP (cached so we don't call API every save)
let cachedIP = null;
async function getUserIP() {
  if (cachedIP) return cachedIP;
  try {
    const res = await fetch("https://api.ipify.org?format=json");
    const data = await res.json();
    cachedIP = data.ip;
    return cachedIP;
  } catch (e) {
    console.warn("⚠️ Failed to fetch IP", e);
    cachedIP = "unknown";
    return cachedIP;
  }
}

async function saveSessionToFirestore(username, state = null, paper = null) {
  if (!username) return false;
  try {
    // ✅ Ensure IP is fetched once per user session
    if (!EXAM.state.ip) {
      EXAM.state.ip = await getUserIP();
    }

    // Build payload: lightweight snapshot to reconstruct session
    const payload = {
      remainingMs: state?.remainingMs ?? EXAM.state?.remainingMs ?? 0,
      updatedAt: Date.now(),
      startedAt: state?.startedAt ?? EXAM.state?.startedAt ?? Date.now(),
      cur: state?.cur ?? EXAM.cur ?? 0,
      paperIds: paper ? paper.map(p => p.id) : (EXAM.paper ? EXAM.paper.map(p => p.id) : []),
      answers: state?.answers ?? EXAM.state?.answers ?? {},
      flags: state?.flags ?? EXAM.state?.flags ?? {},
      locked: (state && state.hasOwnProperty('locked')) 
                ? !!state.locked 
                : !!(typeof examPaused !== 'undefined' && examPaused),
      ip: EXAM.state.ip || "unknown"   // ✅ add IP here
    };

    // Optional unlock metadata
    if (state?.unlockedBy) payload.unlockedBy = state.unlockedBy;
    if (state?.unlockedAt) payload.unlockedAt = state.unlockedAt;

    await setDoc(doc(db, "sessions", username), payload, { merge: true });
    return true;
  } catch (err) {
    console.warn("⚠️ Could not save session:", err);
    return false;
  }
}



// Increment resume counter atomically (client-side simple approach)
async function incrementSessionResumeCount(username) {
  if (!username) return;
  try {
    const ref = doc(db, "sessions", username);
    // read existing
    const snap = await getDoc(ref);
    let current = 0;
    if (snap.exists()) {
      const d = snap.data();
      current = Number(d.resumes || 0);
    }
    const updated = current + 1;
    await setDoc(ref, { resumes: updated, updatedAt: Date.now() }, { merge: true });
    // console.log("↩ Resumes for", username, "->", updated);
    return updated;
  } catch (err) {
    console.warn("⚠️ Failed to increment resume count:", err);
    return null;
  }
}

// Load full session doc and return object (or null)
async function loadSessionDoc(username) {
  if (!username) return null;
  try {
    const snap = await getDoc(doc(db, "sessions", username));
    if (!snap.exists()) return null;
    return snap.data();
  } catch (err) {
    console.warn("⚠️ Failed to load session doc:", err);
    return null;
  }
}

/* Hook into unload/refresh so we save current state and increment resume counter.
   This will run when user refreshes or closes page. We use navigator.sendBeacon if
   available for more reliable background sending; otherwise fall back to async setDoc.
*/
window.addEventListener("beforeunload", async (ev) => {
  // If exam in progress and not submitted, save session and increment counter
  if (EXAM.state && !EXAM.state.submitted) {
    try {
      // first save the lightweight session
      await saveSessionToFirestore(EXAM.state.username);
      // increment resume counter (best-effort)
      // Don't `await` increment when using sendBeacon; work best-effort
      incrementSessionResumeCount(EXAM.state.username);
    } catch (err) {
      console.warn("⚠️ beforeunload save error", err);
    }
  }
  // no need to prevent unload
});

// also save periodically (every 10s) so we can resume with up-to-date state
let RESUME_SAVE_INTERVAL = null;
function startPeriodicSessionSave() {
  if (RESUME_SAVE_INTERVAL) clearInterval(RESUME_SAVE_INTERVAL);
  RESUME_SAVE_INTERVAL = setInterval(() => {
    if (EXAM.state && !EXAM.state.submitted) {
      saveSessionToFirestore(EXAM.state.username);
    }
  }, 10_000);
}
function stopPeriodicSessionSave() {
  if (RESUME_SAVE_INTERVAL) { clearInterval(RESUME_SAVE_INTERVAL); RESUME_SAVE_INTERVAL = null; }
}

/* Check whether user has exceeded max resume allowed (2)
   Returns true if allowed to start/resume, false if blocked.
*/
async function checkResumeLimitAllowed(username) {
  if (!username) return false;
  try {
    const sess = await loadSessionDoc(username);
    const count = (sess && Number(sess.resumes || 0)) || 0;
    const allowedMax = (settings && Number(settings.maxResumes)) || 2;
    return count < allowedMax;
  } catch (err) {
    console.warn("⚠️ checkResumeLimitAllowed failed", err);
    return true; // permissive on error
  }
}

/* Try to restore session for user (if session exists and resumeAllowed)
   This reconstructs EXAM.paper (based on existing question bank) and EXAM.state.
*/
async function tryRestoreSession(user) {
  if (!user || !user.username) return false;
  // Load session doc
  const sess = await loadSessionDoc(user.username);
  if (!sess) return false;

  // If no session.save data, nothing to restore
  if (!Array.isArray(sess.paperIds) || sess.paperIds.length === 0) return false;

  // Build a fresh EXAM.paper in the same order as saved (by IDs)
  const paper = sess.paperIds.map(id => {
    const q = questions.find(x => x.id === id);
    return q ? { id: q.id, question: q.question, options: q.options, answer: q.answer, marks: q.marks, category: q.category } : null;
  }).filter(Boolean);

  if (paper.length === 0) return false;

  // Set EXAM fields
  EXAM.paper = paper;
  EXAM.cur = typeof sess.cur === "number" ? sess.cur : 0;

  // Restore state object (answers / flags / remainingMs)
  EXAM.state = {
    username: user.username,
    answers: sess.answers || {},
    flags: sess.flags || {},
    startedAt: sess.startedAt || Date.now(),
    durationMs: (Number(settings.durationMin || EXAM.cfg.durationMin) * 60_000) || (sess.remainingMs || 0),
    remainingMs: Number(sess.remainingMs || 0),
    submitted: false
  };

  // clamp remainingMs
  const durationMs = Math.max(1, Number(settings.durationMin || EXAM.cfg.durationMin)) * 60_000;
  EXAM.state.remainingMs = Math.min(Math.max(0, EXAM.state.remainingMs), durationMs);

  // show UI
  $('#examFullscreen').style.display = 'flex';
  $('#fsPhoto').src = user.photo || '';
  $('#fsName').textContent = user.fullName || user.username;
  paintQuestion();
  startPeriodicSessionSave();
  startTimer();

  return true;
}

/* ----------------------------
   Integrations: modify start/login flow
   ---------------------------- */

// 1) In handleUserLogin() we should check resume-limit before starting exam.
// Replace the call to startExam(user) with the code below (or modify handleUserLogin):
//  - If user has existing session and allowed -> ask to resume or start new
//  - If resume count >=2 -> block start
//  - If no session -> start normally

/* Example replacement inside handleUserLogin() (replace the `startExam(user)` line):
   -- IMPORTANT: If you already have startExam(user) call, replace it with the snippet below.
*/
async function handleUserLogin_withResume() {
  const username = $('#userName').value.trim();
  const pass = $('#userPass').value;
  const file = document.getElementById('userPhoto').files[0];

  if(!username || !pass) return alert('Enter username and password');

  let user = users.find(u => u.username === username && u.password === pass);
  if(!user){
    if(!file) return alert('New user: upload photo to register');
    const photo = await fileToDataURL(file);
    const fullName = username;
    user = { username, password: pass, photo, fullName };
    users.push(user);
    saveToFirestore("users", user.username, user);
  }

  // check if user already submitted via results
  const arr = await getResultsArray();
  if (arr.some(r => r.username === username)) {
    alert(`⚠️ "${username}" has already attempted the exam.`);
    return;
  }

  // ensure settings loaded
  await loadSettingsFromFirestore();

  // check resume limit
  const allowed = await checkResumeLimitAllowed(username, 2);
  if (!allowed) {
    alert(`⚠️ You have exceeded the maximum number of allowed refresh/close/resume actions (2). Login blocked.`);
    return;
  }

  // try to load session doc
  const sess = await loadSessionDoc(username);
  if (sess && sess.remainingMs && sess.remainingMs > 0) {
    // Ask user whether to resume. (If you prefer auto-resume, skip confirm).
    if (confirm("A saved session was found. Do you want to resume where you left off?")) {
      // restore
      const restored = await tryRestoreSession(user);
      if (restored) {
        // increment resume count — because user is resuming after a close/refresh
        const newCount = await incrementSessionResumeCount(username);
        // let admin know if near limit
        if (newCount >= 2) {
          alert(`⚠️ You have used ${newCount} resume(s). Further resumes will be blocked.`);
        }
        return;
      } else {
        // if restore failed, fallback to fresh start
        startExam(user);
        startPeriodicSessionSave();
        return;
      }
    } else {
      // user chose to start a fresh exam: clear previous session doc and start
      await setDoc(doc(db, "sessions", username), { remainingMs: 0, updatedAt: Date.now(), paperIds: [], answers: {}, flags: {}, resumes: 0 }, { merge: true });
      startExam(user);
      startPeriodicSessionSave();
      return;
    }
  }

  // no session -> start fresh
  startExam(user);
  startPeriodicSessionSave();
}

// Export wrapper so you can swap with existing handleUserLogin
window.handleUserLogin_withResume = handleUserLogin_withResume;

/* ----------------------------
   Integrate with startExam() / submitExam()
   ---------------------------- */

// When startExam(user) is called, we already set EXAM.state and EXAM.paper.
// After building EXAM.paper and EXAM.state inside startExam(), also save initial session:
async function _afterStartExamSaveSession(user) {
  if (!user || !user.username) return;
  // save the paper ids + state
  await saveSessionToFirestore(user.username, EXAM.state, EXAM.paper);
  // ensure periodic saves started
  startPeriodicSessionSave();
}

// Call _afterStartExamSaveSession(EXAM.state.username) near end of startExam()
// (or place one line: await saveSessionToFirestore(user.username); after paintQuestion(); startTimer();)

/* Also on successful final submit, clear the session so they can't resume */
async function _clearSessionAfterSubmit(username) {
  try {
    await setDoc(doc(db, "sessions", username), { remainingMs: 0, updatedAt: Date.now(), paperIds: [], answers: {}, flags: {}, resumes: 0 }, { merge: true });
  } catch (err) {
    console.warn("⚠️ failed to clear session after submit", err);
  }
}

// You should call _clearSessionAfterSubmit(EXAM.state.username) at the end of submitExam() after saving results.


function paintQuestion() {
  const q = EXAM.paper[EXAM.cur];
  if (!q) return;

  // ✅ Question text directly, no leading newline/space
  $('#fsQuestion').innerHTML =
    `${EXAM.cur+1}. (${q.category}) ${escapeHTML(q.question)}`;

  // render options
  const opts = $('#fsOptions'); 
  opts.innerHTML = '';

  q.options.forEach((opt, i) => {
    const d = document.createElement('div');
    d.className = 'fsOpt' + (EXAM.state.answers[q.id] === i ? ' selected' : '');

    // option text
    d.innerHTML = `
      <div style="width:28px;font-weight:800">${String.fromCharCode(65+i)}.</div>
      <div style="flex:1">${escapeHTML(opt)}</div>
    `;

    d.onclick = () => { 
      EXAM.state.answers[q.id] = i; 
      paintQuestion(); 
      updateProgress(); 
    };

    opts.appendChild(d);
  });

  // meta info
  $('#fsMeta').textContent = 
    `Question ${EXAM.cur+1} of ${EXAM.paper.length} • Answered: ${Object.keys(EXAM.state.answers).length}`;
  
  if (EXAM.state.flags[q.id]) {
    $('#fsMeta').textContent += " • ⚑ Flagged";
  }

  updateProgress();
  renderQuestionNav(); // refresh navigation buttons
updateStats();

}

function prevQuestion(){ if(EXAM.cur>0){ EXAM.cur--; paintQuestion(); } }
function nextQuestion(){ if(EXAM.cur < EXAM.paper.length - 1){ EXAM.cur++; paintQuestion(); } }

function toggleFlag(){ const q = EXAM.paper[EXAM.cur]; if(!q) return; EXAM.state.flags[q.id] = !EXAM.state.flags[q.id]; paintQuestion(); }

function updateProgress(){ const answered = Object.keys(EXAM.state.answers).length; const total = EXAM.paper.length; const pct = Math.round((answered/total) * 100); $('#fsProgressFill').style.width = pct + '%'; }

/* NEW: Question navigator */
function renderQuestionNav(){
  const nav = document.getElementById('questionNav');
  nav.innerHTML = '';
  EXAM.paper.forEach((q,i)=>{
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = i+1;
    // mark answered
    if(EXAM.state.answers[q.id] !== undefined) btn.style.background = '#34d399';
    // highlight current
    if(i === EXAM.cur) btn.style.outline = '2px solid #60a5fa';
    btn.onclick = ()=>{ EXAM.cur = i; paintQuestion(); };
    nav.appendChild(btn);
  });
}

/* Timer */
function startTimer() {
  stopTimer();
  const end = Date.now() + EXAM.state.remainingMs;
  updateTimerText();

  EXAM.timerId = setInterval(async () => {
    EXAM.state.remainingMs = end - Date.now();

    if (EXAM.state.remainingMs <= 0) {
      EXAM.state.remainingMs = 0;
      stopTimer();
      if (settings.allowAfterTime) {
              } else {
        submitExam(true);
      }
    }

    updateTimerText();

    // 🔹 Save timer to Firestore every 10s
    if (Math.floor(EXAM.state.remainingMs / 10000) !== Math.floor((EXAM.state.remainingMs + 500) / 10000)) {
      try {
        await setDoc(
          doc(db, "timers", EXAM.state.username),
          { remainingMs: EXAM.state.remainingMs, updatedAt: Date.now() },
          { merge: true }
        );
        console.log("⏳ Timer saved for", EXAM.state.username);
      } catch (err) {
        console.warn("⚠️ Could not save timer:", err);
      }
    }

  }, 500);
}
// ---- Lock / unlock helpers (improved) ----
async function lockExamForUser(reason = '') {
  if (!EXAM.state || !EXAM.state.username) return;
  try {
    EXAM.state.locked = true;
    EXAM.state.lockReason = reason || '';
    // save immediately so admin sees it
    if (typeof saveSessionToFirestore === 'function') {
      await saveSessionToFirestore(EXAM.state.username, EXAM.state, EXAM.paper);
    } else {
      // fallback: write minimal payload
      await setDoc(doc(db, "sessions", EXAM.state.username), {
        locked: true,
        lockReason: EXAM.state.lockReason,
        updatedAt: Date.now()
      }, { merge: true });
    }
  } catch (err) {
    console.warn("lockExamForUser: failed to persist session", err);
  }

  // show lock UI locally (if not shown already)
  try { $('#lockScreen').style.display = 'flex'; } catch(e){}

  // Force refresh admin sessions instantly (if admin is viewing)
  if (window.IS_ADMIN && typeof renderSessionsAdmin === 'function') {
    try { renderSessionsAdmin(); } catch (e) { console.warn(e); }
  }
}

async function unlockExamForUser() {
  if (!EXAM?.state || !EXAM.state.username) return;
  const username = EXAM.state.username;

  try {
    // update local state first
    EXAM.state.locked = false;
    EXAM.state.lockReason = '';

    // server payload with audit info
    const payload = {
      locked: false,
      unlockedBy: (window.ADMIN_NAME || window.currentAdmin || "admin"),
      unlockedAt: Date.now(),
      updatedAt: Date.now()
    };

    // prefer existing helper (merges); otherwise fall back to setDoc
    if (typeof saveSessionToFirestore === 'function') {
      // pass explicit locked:false so saveSessionToFirestore keeps it
     await saveSessionToFirestore(username, { ...EXAM.state, ...payload }, EXAM.paper);
    } else {
      await setDoc(doc(db, "sessions", username), payload, { merge: true });
    }
  } catch (err) {
    console.warn("unlockExamForUser: failed to persist session", err);
  }

  // hide lock UI locally (works whether you use $ or plain DOM)
  try {
    const el = document.getElementById('lockScreen');
    if (el) el.style.display = 'none';
  } catch (e) { /* ignore */ }

  // If this client was the locked user, resume timer/UI
  try {
    if (EXAM && EXAM.state && EXAM.state.username === username) {
      if (examPaused) {
        examPaused = false;
        try { startTimer(); } catch (e) { console.warn("startTimer failed:", e); }
        try { startPeriodicSessionSave(); } catch (e) {}
      }
      EXAM.state.locked = false;
    }
  } catch (e) {
    console.warn("unlockExamForUser: resume UI error", e);
  }

  // Refresh admin view if present
  if (window.IS_ADMIN && typeof renderSessionsAdmin === 'function') {
    try { renderSessionsAdmin(); } catch (e) { console.warn(e); }
  }

  // Stop only the poller fallback (keep realtime watcher active)
  if (typeof stopPausedSessionPolling === 'function') stopPausedSessionPolling();

  // IMPORTANT: DO NOT call stopSessionWatcher() here.
  // Only call stopSessionWatcher() when the exam session ends (submit) or user logs out.
}

// Optional: also lock when tab/window becomes hidden (user switched tab)
document.addEventListener('visibilitychange', async () => {
  try {
    if (document.visibilityState === 'hidden' && EXAM.state && !EXAM.state.submitted) {
      await lockExamForUser('visibility-hidden');
    }
  } catch (e) {
    console.warn('visibilitychange handler error', e);
  }
});
// ---------- Realtime session watcher (more reliable than polling) ----------
let SESSION_UNSUBSCRIBE = null;

function startSessionWatcher(username) {
  try {
    // unsubscribe previous listener if present (safe re-subscribe behavior)
    if (SESSION_UNSUBSCRIBE) {
      try { SESSION_UNSUBSCRIBE(); } catch(e) {}
      SESSION_UNSUBSCRIBE = null;
    }

    if (!username) return;
    const ref = doc(db, "sessions", username);

    // Attach realtime listener and KEEP it active (do NOT unsubscribe inside the callback)
    SESSION_UNSUBSCRIBE = onSnapshot(ref, snap => {
      try {
        if (!snap.exists()) return;
        const s = snap.data();
        console.log("session watcher:", username, s);

        if (s.locked) {
          // When locked: show lock UI and stop timer
          examPaused = true;
          if (typeof stopPausedSessionPolling === 'function') stopPausedSessionPolling();
          if (document.getElementById("lockScreen")) {
            document.getElementById("lockScreen").style.display = "flex";
          }
          if (EXAM && EXAM.timerId) {
            clearInterval(EXAM.timerId);
            EXAM.timerId = null;
          }
          // keep listening for unlock events
          return;
        }

        // When unlocked: resume UI & timer (use server state as source-of-truth)
        // stop poller (compat) and resume user UI
        if (typeof stopPausedSessionPolling === 'function') stopPausedSessionPolling();

        if (document.getElementById("lockScreen")) {
          document.getElementById("lockScreen").style.display = "none";
        }

        // If the local client was paused, resume timer and state
        if (examPaused) {
          examPaused = false;
          // update local EXAM.state so future saves reflect unlocked
          if (EXAM && EXAM.state) EXAM.state.locked = false;

          // attempt to restart timer and periodic saves (your implementations)
          try { startTimer(); } catch (e) { console.warn("startTimer failed:", e); }
          try { startPeriodicSessionSave(); } catch (e) { console.warn("startPeriodicSessionSave failed:", e); }

          console.info("✅ Unlocked by admin — resuming exam.");
        } else {
          // Not paused locally but server says unlocked — ensure local state matches
          if (EXAM && EXAM.state) EXAM.state.locked = false;
        }
        // IMPORTANT: DO NOT unsubscribe here — keep listening for future events
      } catch (err) {
        console.warn("session watcher callback error", err);
      }
    }, err => {
      console.warn("session watcher onSnapshot error:", err);
      // If snapshot repeatedly fails, fall back to poller
      if (typeof startPausedSessionPolling === 'function') startPausedSessionPolling(username);
    });
  } catch (err) {
    console.warn("startSessionWatcher failed:", err);
    if (typeof startPausedSessionPolling === 'function') startPausedSessionPolling(username);
  }
}

// Call this when the exam ends or the user logs out to stop listening
function stopSessionWatcher() {
  if (SESSION_UNSUBSCRIBE) {
    try { SESSION_UNSUBSCRIBE(); } catch (e) { console.warn("stopSessionWatcher unsub error", e); }
    SESSION_UNSUBSCRIBE = null;
  }
}


function stopSessionWatcher() {
  try {
    if (SESSION_UNSUBSCRIBE) { SESSION_UNSUBSCRIBE(); SESSION_UNSUBSCRIBE = null; }
  } catch (e) { /* ignore */ }
}

function stopTimer(){ if(EXAM.timerId){ clearInterval(EXAM.timerId); EXAM.timerId = null; } }
function updateTimerText(){ const ms = Math.max(0, EXAM.state.remainingMs); $('#fsTimer').textContent = msToTime(ms); }
function msToTime(ms){ const s = Math.floor(ms/1000); const hh = String(Math.floor(s/3600)).padStart(2,'0'); const mm = String(Math.floor((s%3600)/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return `${hh}:${mm}:${ss}`; }

/* Submit exam: calculate marks, per-section scores, save results, show percent & progress bar only */
function renderQuestionNav(){
  const nav = document.getElementById('questionNav');
  nav.innerHTML = '';
  EXAM.paper.forEach((q,i)=>{
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = i+1;
    if(EXAM.state.answers[q.id] !== undefined) {
  btn.style.background = '#34d399'; // green if answered
}
if(EXAM.state.flags[q.id]) {
  btn.style.border = '2px solid orange'; // orange border for flagged
}
if(i === EXAM.cur) {
  btn.style.outline = '2px solid #60a5fa'; // blue outline for current
}

    btn.onclick = ()=>{ EXAM.cur = i; paintQuestion(); };
    nav.appendChild(btn);
  });
}

async function submitExam(auto = false) {
  if (!auto && !confirm('Submit exam now?')) return;

  // 🔒 Limit attempts (max 1 per user)
  const MAX_ATTEMPTS = 1;
  const arr = await getResultsArray();
  const userAttempts = arr.filter(r => r.username === EXAM.state.username);

  if (userAttempts.length >= MAX_ATTEMPTS) {
    alert(`⚠️ User "${EXAM.state.username}" has already attempted the exam ${MAX_ATTEMPTS} time(s).`);
    $('#examFullscreen').style.display = 'none';
    showSection('user');
    return;
  }

  stopTimer();
  const paper = EXAM.paper;
  let totalMarks = 0, earned = 0;
  const sectionScores = { 'Synopsis': 0, 'Minor Practical': 0, 'Major Practical': 0, 'Viva': 0 };

  paper.forEach(q => {
    totalMarks += (q.marks || 1);
    const chosen = EXAM.state.answers[q.id];

    if (q.category === "Major Practical") {
      if (chosen === 0) { // A → full marks
        earned += q.marks;
        sectionScores[q.category] += q.marks;
      }
      else if (chosen === 1) { // B → 75%
        const val = Math.round(q.marks * 0.75);
        earned += val;
        sectionScores[q.category] += val;
      }
      else if (chosen === 2) { // C → 50%
        const val = Math.round(q.marks * 0.5);
        earned += val;
        sectionScores[q.category] += val;
      } else {
        // D → 0 marks
      }
    } else {
      if (chosen === q.answer) {
        earned += (q.marks || 1);
        sectionScores[q.category] = (sectionScores[q.category] || 0) + (q.marks || 1);
      }
    }
  });

  // round marks before calculating percentage
  earned = Math.round(earned);
  Object.keys(sectionScores).forEach(k => { sectionScores[k] = Math.round(sectionScores[k]); });

  const percent = Math.round((earned / Math.max(1, totalMarks)) * 100);

  // 🔹 Save results - synchronous flow (await each step so admin can see immediately)
  try {
    // 1) Ensure results is an array in memory (load/decrypt if needed)
    let currentResults = [];
    if (Array.isArray(results)) {
      currentResults = results;
    } else {
      // try to read + decrypt local storage
      const stored = read(K_RESULTS, null);
      if (stored) {
        try {
          currentResults = await decryptData(stored);
          if (!Array.isArray(currentResults)) currentResults = [];
        } catch (e) {
          console.warn("Could not decrypt existing results from localStorage", e);
          currentResults = [];
        }
      } else {
        currentResults = [];
      }
    }

    // 2) Create and push new record
    const record = {
      username: EXAM.state.username,
      totalScorePercent: percent,
      sectionScores,
      timestamp: Date.now()
    };
    currentResults.push(record);

    // 3) Encrypt and persist to localStorage
    const encryptedResults = await encryptData(currentResults);
    write(K_RESULTS, encryptedResults);

    // 4) Save encrypted bundle to Firestore (attempt)
    try {
      await setDoc(doc(db, "results", "all"), { data: encryptedResults });
      console.log("✅ Results synced to Firestore (encrypted)");
    } catch (err) {
      console.warn("❌ Firestore save error (results) - continuing offline only", err);
    }

    // 5) Update in-memory results variable so renderResults() uses the latest
    results = currentResults;

    // 6) Refresh admin results UI (if admin is viewing)
    if (typeof renderResults === 'function') {
      try { renderResults(); } catch (err) { console.warn('renderResults() failed', err); }
    }

    // 7) (Optional) Auto-download backup as before
    const filename = `results_${EXAM.state.username}_${Date.now()}.json`;
    download(filename, JSON.stringify(encryptedResults, null, 2), 'application/json');

  } catch (err) {
    console.error("❌ Error while saving results:", err);
    alert("⚠️ Failed to save results properly. Check console.");
  }

  // 🔹 Clear session so user cannot resume
  await _clearSessionAfterSubmit(EXAM.state.username);
  stopPeriodicSessionSave();

  // 🔹 Show score & redirect
  $('#fsQuestion').innerHTML = `
    <div style="text-align:center;font-size:22px;font-weight:900">
      Your Score: ${percent}%
    </div>
    <div id="redirectMsg" style="text-align:center;margin-top:10px;font-size:14px;color:var(--muted)">
      Redirecting in 5s...
    </div>
  `;
  $('#fsOptions').innerHTML = `<div class="progress-bar"><div class="progress-fill" style="width:${percent}%"></div></div>`;

  document.querySelectorAll('.fsFooter').forEach(el => el.style.display = 'flex');
  EXAM.state.submitted = true;

  let secs = 5;
  const msgEl = document.getElementById('redirectMsg');
  const countdown = setInterval(() => {
    secs--;
    if (secs > 0) {
      msgEl.textContent = `Redirecting in ${secs}s...`;
    } else {
      clearInterval(countdown);
      $('#examFullscreen').style.display = 'none';
      showSection('user');
    }
  }, 1000);
}

/* Close fullscreen and return to main page (reload to refresh admin view) */
function closeFullscreen() { 
  stopTimer(); 
  $('#examFullscreen').style.display = 'none'; 
  location.reload(); 
}

/* ---------- ADMIN: login, CRUD, import/export, results ---------- */

function handleAdminLogin(){
  const pass = $('#adminPass').value;
  const stored = read(K_ADMIN, null);

  if(stored && stored.password === pass){ 
    enterAdmin(); 
    renderAdminAnnouncementsLive();   // 🔑 start live announcements in admin panel
    return; 
  }
  if(pass === MASTER_ADMIN.password){ 
    enterAdmin(); 
    renderAdminAnnouncementsLive();   // 🔑 same for master admin
    return; 
  }
  alert('Invalid admin password');
}


function enterAdmin(){
  // show admin panel
  showSection('adminPanel');

  // mark admin state and enable the sessions UI (only visible to admins)
  window.IS_ADMIN = true;
  if (typeof enableAdminSessionsUI === 'function') {
    enableAdminSessionsUI(true);
  } else {
    console.warn('enableAdminSessionsUI not found - ensure helper is loaded');
  }

  // render admin content
  renderQuestionsList();
  renderUsersAdmin();
  renderResults();
  renderSettingsAdmin();
}

/* Call this when admin logs out / clicks Back */
function logoutAdmin() {
  // clear admin state and hide admin-only UI
  window.IS_ADMIN = false;
  if (typeof enableAdminSessionsUI === 'function') {
    enableAdminSessionsUI(false);
  }
  // show the default user/home section
  showSection('user'); // or 'home' depending on your flow
}

/* Questions CRUD in admin */
let editingId = null;
/* ---------- Save Question ---------- */
async function saveQuestion() {
  const text = $('#qText').value.trim();
  const opts = [$('#qA').value.trim(), $('#qB').value.trim(), $('#qC').value.trim(), $('#qD').value.trim()];
  const ans = parseInt($('#qAnswer').value) || 0;
  const marks = parseInt($('#qMarks').value) || 1;
  const category = $('#qCategory').value;

  if (!text || opts.some(o => !o)) {
    alert('⚠️ Fill question and all 4 options');
    return;
  }

  const q = {
    id: editingId || uid(),
    question: text,
    options: opts,
    answer: ans,
    marks,
    category
  };

  if (editingId) {
    questions = questions.map(x => x.id === q.id ? q : x);
    editingId = null;
  } else {
    questions.push(q);
  }

  write(K_QS, questions);

  try {
   await setDoc(doc(db, "questions", q.id), q);
await loadQuestionsFromFirestore();  // ✅ reload latest from Firestore
renderQuestionsList();


    console.log(`✅ Firestore saved: questions/${q.id}`);
    alert("✅ Question saved to Firebase + localStorage!");
  } catch (err) {
    console.error("❌ Firestore error:", err);
    alert("⚠️ Question saved offline only.\nError: " + err.message);
  }

  clearQuestionForm();
  renderQuestionsList();
}

function clearQuestionForm(){ editingId = null; $('#qText').value=''; $('#qA').value=''; $('#qB').value=''; $('#qC').value=''; $('#qD').value=''; $('#qMarks').value=1; $('#qAnswer').value='0'; $('#qCategory').value='Synopsis'; }
function cancelEdit(){ clearQuestionForm(); }
function renderQuestionsList() {
  const out = $('#questionsList'); 
  out.innerHTML = '';
  if (questions.length === 0) { 
    out.innerHTML = '<div class="small">No questions yet.</div>'; 
    return; 
  }

  questions.forEach((q, i) => {
    const wrapper = document.createElement('div'); 
    wrapper.className = 'list-item';

    const textDiv = document.createElement('div');
    textDiv.style.flex = '1';

    textDiv.innerHTML = `
      <b>${i+1}. [${q.category}]</b>
      <div class="admin-question-text">${escapeHTML(q.question)}</div>
      <div class="small">A) ${escapeHTML(q.options[0])} 
      • B) ${escapeHTML(q.options[1])} 
      • C) ${escapeHTML(q.options[2])} 
      • D) ${escapeHTML(q.options[3])}</div>
      <div class="small">Marks: ${q.marks}</div>
    `;

    const editBtn = document.createElement('button'); 
    editBtn.className = 'btn'; 
    editBtn.textContent = 'Edit'; 
    editBtn.onclick = () => { loadQuestionToForm(q.id); };

    const delBtn = document.createElement('button'); 
    delBtn.className = 'btn danger'; 
    delBtn.textContent = 'Delete'; 
    delBtn.onclick = () => { 
      if (confirm('Delete question?')) { 
        questions = questions.filter(x => x.id !== q.id); 
        write(K_QS, questions); 
        renderQuestionsList(); 
      } 
    };

    wrapper.appendChild(textDiv);
    wrapper.appendChild(editBtn);
    wrapper.appendChild(delBtn);

    out.appendChild(wrapper);
  });
}

function loadQuestionToForm(id){
  const q = questions.find(x=>x.id===id); if(!q) return;
  editingId = q.id;
  $('#qText').value = q.question; $('#qA').value=q.options[0]; $('#qB').value=q.options[1]; $('#qC').value=q.options[2]; $('#qD').value=q.options[3];
  $('#qAnswer').value = String(q.answer); $('#qMarks').value = String(q.marks); $('#qCategory').value = q.category;
  window.scrollTo({ top: 0, behavior: 'smooth' });
}
function clearAllQuestions(){ if(!confirm('Delete ALL questions?')) return; questions = []; write(K_QS, questions); renderQuestionsList(); }

/* ---------------- USERS ADMIN ---------------- */
async function toDataURL(file){ 
  return new Promise(res => { 
    const fr = new FileReader(); 
    fr.onload = ()=> res(fr.result); 
    fr.readAsDataURL(file); 
  }); 
}

/* ---------- Create / Update User ---------- */
async function adminCreateUser(){
  const u = $('#adminNewUser').value.trim(); 
  const fName = $('#adminNewFull').value.trim();
  const p = $('#adminNewPass').value; 
  const f = $('#adminNewPhoto').files[0];

  if(!u || !p) return alert('⚠️ Username & password required');

  const photo = f ? await toDataURL(f) : '';
  const obj = { username: u, fullName: fName, password: p, photo };

  const idx = users.findIndex(x=>x.username===u);
  if(idx >= 0) {
    // update existing
    if(photo) obj.photo = photo; else obj.photo = users[idx].photo;
    users[idx] = obj;
  } else {
    users.push(obj);
  }

  // Save offline
  write(K_USERS, users);
  renderUsersAdmin();

  // Save online (Firestore)
  try {
    await setDoc(doc(db, "users", obj.username), obj);
    console.log(`✅ Firestore saved: users/${obj.username}`);
    alert(`✅ User "${obj.username}" saved to Firebase + localStorage!`);
  } catch (err) {
    console.error("❌ Firestore error (users):", err);
    alert(`⚠️ User "${obj.username}" saved offline only.\nError: ${err.message}`);
  }

  // clear form
  $('#adminNewUser').value='';
  $('#adminNewFull').value='';
  $('#adminNewPass').value='';
  $('#adminNewPhoto').value='';
}

function adminEditUser(i){
  const u = users[i];
  $('#adminNewUser').value = u.username;
  $('#adminNewFull').value = u.fullName || '';
  $('#adminNewPass').value = u.password;
  // photo left blank so admin can choose new one
}
function adminDeleteUser(i){
  if(confirm("Delete this user?")){
    users.splice(i,1);
    write(K_USERS, users);
    renderUsersAdmin();
  }
}

function renderUsersAdmin(){
  const box = $('#adminUsersList');
  box.innerHTML = '';
  users.forEach((u, i) => {
    const div = document.createElement('div');
    div.className = 'userRow';
    div.innerHTML = `
      <img src="${u.photo || ''}" class="userPhoto">
      <span><b>${u.fullName || ''}</b> (${u.username})</span>
      <button onclick="adminEditUser(${i})">Edit</button>
      <button onclick="adminDeleteUser(${i})">Delete</button>
    `;
    box.appendChild(div);
  });
}


function adminClearUsers(){ if(!confirm('Delete ALL users?')) return; users = []; write(K_USERS, users); renderUsersAdmin(); }

/* Results admin */
// Replace existing renderResults() with this improved version
async function renderResults() {
  const out = $('#resultsArea');
  out.innerHTML = '<div class="small">Loading latest results…</div>';

  // Helper to render decrypted array to table
  function renderTable(decrypted) {
    if (!Array.isArray(decrypted) || decrypted.length === 0) {
      out.innerHTML = '<div class="small">No results yet</div>';
      return;
    }
    const table = document.createElement('table');
    table.className = 'table';
    const thead = document.createElement('thead');
    thead.innerHTML = '<tr><th>User</th><th>Total %</th><th>Synopsis</th><th>Minor Practical</th><th>Major Practical</th><th>Viva</th><th>Time</th></tr>';
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    decrypted.forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.username}</td>
        <td>${r.totalScorePercent}</td>
        <td>${r.sectionScores['Synopsis'] || 0}</td>
        <td>${r.sectionScores['Minor Practical'] || 0}</td>
        <td>${r.sectionScores['Major Practical'] || 0}</td>
        <td>${r.sectionScores['Viva'] || 0}</td>
        <td>${new Date(r.timestamp).toLocaleString()}</td>
      `;
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    out.innerHTML = '';
    out.appendChild(table);
  }

  // 1) Try Firestore first (if initialized)
  try {
    const snap = await getDoc(doc(db, "results", "all"));
    if (snap && snap.exists && snap.exists()) {
      const enc = snap.data().data;
      if (enc) {
        try {
          const decrypted = await decryptData(enc);
          // update local storage and in-memory variable
          const encryptedLocal = await encryptData(decrypted);
          write(K_RESULTS, encryptedLocal);
          results = decrypted;
          console.log("✅ Loaded results from Firestore and updated local storage");
          renderTable(decrypted);
          return;
        } catch (err) {
          console.warn("⚠️ Could not decrypt Firestore results:", err);
          // continue to fallback below
        }
      }
    } else {
      console.log("ℹ️ No results found in Firestore (results/all)");
    }
  } catch (err) {
    console.warn("⚠️ Firestore read failed (renderResults):", err);
    // proceed to fallback to local storage
  }

  // 2) Fallback: use local storage K_RESULTS
  let stored = read(K_RESULTS, null);
  if (!stored) {
    out.innerHTML = '<div class="small">No results yet</div>';
    return;
  }
  try {
    const decrypted = await decryptData(stored);
    results = decrypted;
    renderTable(decrypted);
    console.log("✅ Loaded results from local storage");
  } catch (err) {
    out.innerHTML = '<div class="small danger">⚠️ Failed to decrypt results</div>';
    console.error("renderResults decrypt error:", err);
  }
}


/* ---------------------------
   Show Live Sessions only after Admin login
--------------------------- */

function enableAdminSessionsUI(enable = true) {
  const card = document.getElementById('adminSessionsCard');
  if (!card) return;

  if (enable) {
    card.style.display = 'block';
    renderSessionsAdmin().catch(err => console.warn('renderSessionsAdmin error', err));
    const cb = document.getElementById('adminAutoRefreshSessions');
    if (cb && cb.checked && !SESSIONS_AUTO_REFRESH_ID) {
      SESSIONS_AUTO_REFRESH_ID = setInterval(renderSessionsAdmin, 5000);
    }
  } else {
    card.style.display = 'none';
    if (SESSIONS_AUTO_REFRESH_ID) {
      clearInterval(SESSIONS_AUTO_REFRESH_ID);
      SESSIONS_AUTO_REFRESH_ID = null;
    }
  }
}

// ------------------ Admin: Live sessions viewer ------------------

let SESSIONS_AUTO_REFRESH_ID = null;

async function fetchAllSessionsFromFirestore() {
  try {
    const col = collection(db, "sessions");
    const snap = await getDocs(col);
    const sessions = [];
    snap.forEach(d => sessions.push({ id: d.id, ...d.data() }));
    // sort by updatedAt desc
    sessions.sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0));
    return sessions;
  } catch (err) {
    console.error("❌ Failed to fetch sessions:", err);
    return [];
  }
}

function formatTimeAgo(ts) {
  if (!ts) return '-';
  const diff = Date.now() - ts;
  const sec = Math.floor(diff/1000);
  if (sec < 60) return `${sec}s ago`;
  const min = Math.floor(sec/60);
  if (min < 60) return `${min}m ago`;
  const hr = Math.floor(min/60);
  if (hr < 24) return `${hr}h ago`;
  return new Date(ts).toLocaleString();
}

async function renderSessionsAdmin() {
  const out = document.getElementById('adminSessionsList');
  out.innerHTML = '<div class="small">Loading sessions…</div>';

  const sessions = await fetchAllSessionsFromFirestore();
  if (!sessions || sessions.length === 0) {
    out.innerHTML = '<div class="small">No active sessions found.</div>';
    return;
  }

  // Build a list UI
  out.innerHTML = '';
  sessions.forEach(sess => {
    // try to find user details from local users array
    const user = users.find(u => u.username === sess.id) 
              || users.find(u => u.username === sess.username) 
              || { username: sess.id || sess.username, fullName: sess.username || sess.id, photo: '' };

    const wrapper = document.createElement('div');
    wrapper.className = 'list-item';
    wrapper.style.display = 'flex';
    wrapper.style.alignItems = 'center';
    wrapper.style.justifyContent = 'space-between';

    // left: user photo + name
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.gap = '10px';
    left.style.alignItems = 'center';
    left.innerHTML = `
      <img src="${user.photo || ''}" class="userPhoto" style="width:48px;height:48px;border-radius:8px">
      <div>
        <div style="font-weight:800">${user.fullName || user.username || sess.id}</div>
        <div class="small">${sess.username || sess.id} • ${sess.paperIds ? sess.paperIds.length : '-'} q • resumed ${sess.resumes || 0} time(s)</div>
      </div>
    `;

    // middle: exam status + IP
    const mid = document.createElement('div');
    mid.className = 'small';
    mid.style.minWidth = '220px';
    mid.style.textAlign = 'center';
    mid.innerHTML = `
      <div>Remaining: ${msToTime(Number(sess.remainingMs || 0))}</div>
      <div style="margin-top:4px">${sess.startedAt ? new Date(sess.startedAt).toLocaleString() : '-'}</div>
      <div style="margin-top:4px;color:var(--muted)">${formatTimeAgo(sess.updatedAt)}</div>
      <div style="margin-top:4px">IP: ${sess.ip || 'unknown'}</div>   <!-- ✅ Show IP -->
    `;

    // right: actions
    const actions = document.createElement('div');
    actions.style.display = 'flex';
    actions.style.gap = '8px';

    const isLocked = !!sess.locked;
    actions.innerHTML = `
      <button class="btn" onclick='adminViewSession("${sess.id}")'>View</button>
      <button class="btn" onclick='adminForceClearSession("${sess.id}")'>Clear</button>
      ${isLocked ? `<span class="badge" style="margin-left:8px;background:#f87171;color:white">Locked</span>` : ''}
      ${isLocked ? `<button class="btn brand" onclick='adminUnlockSession("${sess.id}")'>Unlock</button>` : ''}
    `;

    wrapper.appendChild(left);
    wrapper.appendChild(mid);
    wrapper.appendChild(actions);

    out.appendChild(wrapper);
  });
}

// View session detail (simple modal-like alert or console), you can expand to fancy modal
async function adminViewSession(sessionId) {
  try {
    const snap = await getDoc(doc(db, "sessions", sessionId));
    if (!snap.exists()) return alert("No session data found.");
    const s = snap.data();
    let msg = `Session for ${sessionId}\nStarted: ${s.startedAt ? new Date(s.startedAt).toLocaleString() : '-'}\nUpdated: ${s.updatedAt ? new Date(s.updatedAt).toLocaleString() : '-'}\nRemainingMs: ${s.remainingMs}\nResumes: ${s.resumes || 0}\nCurrent Q index: ${s.cur}\nAnswers: ${JSON.stringify(s.answers || {}, null, 2)}\nFlags: ${JSON.stringify(s.flags || {}, null, 2)}\nPaper IDs: ${JSON.stringify(s.paperIds || [], null, 2)}`;
    // show in a scrollable window (new tab)
    const w = window.open();
    w.document.title = `Session: ${sessionId}`;
    w.document.body.style.background = '#071428';
    w.document.body.style.color = '#e6eef8';
    const pre = w.document.createElement('pre');
    pre.textContent = msg;
    pre.style.whiteSpace = 'pre-wrap';
    pre.style.padding = '12px';
    w.document.body.appendChild(pre);
  } catch (err) {
    console.error(err);
    alert('Failed to load session (see console).');
  }
}

// Force clear a session (admin action) — deletes the session doc so user can't resume
async function adminForceClearSession(sessionId) {
  if (!confirm(`Clear session for "${sessionId}"? This will remove their saved progress and prevent resume.`)) return;
  try {
    await setDoc(doc(db, "sessions", sessionId), { remainingMs: 0, updatedAt: Date.now(), paperIds: [], answers: {}, flags: {}, resumes: 0 }, { merge: true });
    // optionally remove doc: use deleteDoc(doc(db,"sessions",sessionId)) if you prefer
    alert("Session cleared.");
    renderSessionsAdmin();
  } catch (err) {
    console.error(err);
    alert("Failed to clear session (see console).");
  }
}

// Clear all sessions (danger)
async function clearAllSessions() {
  if (!confirm('Clear ALL sessions? This will remove all saved progress.')) return;
  // caution: Firestore web SDK doesn't support batch delete of unknown docs easily client-side.
  // we'll list sessions and clear individually (best-effort)
  try {
    const sessions = await fetchAllSessionsFromFirestore();
    for (const s of sessions) {
      await setDoc(doc(db, "sessions", s.id), { remainingMs: 0, updatedAt: Date.now(), paperIds: [], answers: {}, flags: {}, resumes: 0 }, { merge: true });
    }
    alert('All sessions cleared (best-effort).');
    renderSessionsAdmin();
  } catch (err) {
    console.error(err);
    alert('Failed to clear sessions (see console).');
  }
}
  // Admin: remote-unlock a student's session (clears the locked flag)
async function adminUnlockSession(sessionId) {
  if (!confirm(`Unlock session for "${sessionId}"? This will allow the student to resume.`)) return;
  try {
    await setDoc(doc(db, "sessions", sessionId), { locked: false, unlockedAt: Date.now(), updatedAt: Date.now() }, { merge: true });
    alert("Session unlocked.");
    renderSessionsAdmin();
  } catch (err) {
    console.error(err);
    alert("Failed to unlock session (see console).");
  }
}
window.adminUnlockSession = adminUnlockSession; // expose globally for the inline onclick

// Auto-refresh toggle handler: call render every 5s when checked
document.addEventListener('DOMContentLoaded', () => {
  const cb = document.getElementById('adminAutoRefreshSessions');
  if (!cb) return;
  cb.addEventListener('change', () => {
    if (cb.checked) {
      // start auto-refresh
      if (SESSIONS_AUTO_REFRESH_ID) clearInterval(SESSIONS_AUTO_REFRESH_ID);
      SESSIONS_AUTO_REFRESH_ID = setInterval(renderSessionsAdmin, 5000);
    } else {
      if (SESSIONS_AUTO_REFRESH_ID) { clearInterval(SESSIONS_AUTO_REFRESH_ID); SESSIONS_AUTO_REFRESH_ID = null; }
    }
  });
});


function clearResults(){ if(!confirm('Clear all results?')) return; results = []; write(K_RESULTS, results); renderResults(); }
/* Exam Settings */
/* ---------- Save Exam Settings ---------- */
async function saveExamSettings() {
  const dur = parseInt($('#adminDuration').value) || 30;
  const msg = $('#adminCustomMsg').value || "📢 Welcome to your exam! Stay calm, focus, and do your best!";
  const shuffle = $('#adminShuffle').checked;
  const allowAfterTime = $('#adminAllowAfterTime').checked;

  const logoFile = document.getElementById('adminLogo').files[0];
  const logo = logoFile ? await toDataURL(logoFile) : (settings.logo || "");

  // new resume settings
  const resumeEnabled = !!document.getElementById('adminResumeEnabled').checked;
  const maxResumes = Math.max(0, parseInt(document.getElementById('adminMaxResumes').value) || 2);

  const settingsObj = {
    durationMin: dur,
    customMsg: msg,
    shuffle,
    allowAfterTime,
    logo,
    author: document.getElementById('adminAuthor').value || "",
    college: document.getElementById('adminCollege').value || "",
    subject: document.getElementById('adminSubject').value || "",
    subjectCode: document.getElementById('adminSubjectCode').value || "",
    fullMarks: parseInt(document.getElementById('adminFullMarks').value) || 0,
    // resume fields
    resumeEnabled,
    maxResumes,
    counts: {
      Synopsis: parseInt($('#adminCountSynopsis').value) || 0,
      "Minor Practical": parseInt($('#adminCountMinor').value) || 0,
      "Major Practical": parseInt($('#adminCountMajor').value) || 0,
      Viva: parseInt($('#adminCountViva').value) || 0
    }
  };

  // update global and persist
  settings = settingsObj;
  write(K_SETTINGS, settings);

  try {
    await setDoc(doc(db, "settings", "exam"), settingsObj);
    await loadSettingsFromFirestore(); // reload remote copy
    console.log("✅ Firestore saved: settings/exam", settingsObj);
    alert("✅ Exam settings saved to Firebase + localStorage!");
  } catch (err) {
    console.error("❌ Firestore error (settings):", err);
    alert("⚠️ Exam settings saved offline only.\nError: " + err.message);
  }

  // update UI
  renderSettingsAdmin();
  renderExamHeader();
}


function renderSettingsAdmin() {
  // default fallback
  if (!settings || typeof settings !== "object") {
    settings = {
      durationMin: 30,
      customMsg: "",
      shuffle: false,
      allowAfterTime: false,
      logo: "",
      author: "",
      college: "",
      subject: "",
      subjectCode: "",
      fullMarks: "",
      resumeEnabled: false,
      maxResumes: 2,
      counts: { Synopsis: 0, "Minor Practical": 0, "Major Practical": 0, Viva: 0 }
    };
  }

  // Timer & exam settings
  document.getElementById('adminDuration').value = settings.durationMin || "";
  document.getElementById('adminCustomMsg').value = settings.customMsg || "";
  document.getElementById('adminShuffle').checked = !!settings.shuffle;
  document.getElementById('adminAllowAfterTime').checked = !!settings.allowAfterTime;

  // resume UI
  const resumeEl = document.getElementById('adminResumeEnabled');
  if (resumeEl) resumeEl.checked = !!settings.resumeEnabled;
  const maxR = document.getElementById('adminMaxResumes');
  if (maxR) maxR.value = typeof settings.maxResumes === 'number' ? settings.maxResumes : (settings.maxResumes || 2);

  // Extra fields
  document.getElementById('adminAuthor').value = settings.author || "";
  document.getElementById('adminCollege').value = settings.college || "";
  document.getElementById('adminSubject').value = settings.subject || "";
  document.getElementById('adminSubjectCode').value = settings.subjectCode || "";
  document.getElementById('adminFullMarks').value = settings.fullMarks || "";

  // Counts
  document.getElementById('adminCountSynopsis').value = settings.counts?.Synopsis || "";
  document.getElementById('adminCountMinor').value = settings.counts?.["Minor Practical"] || "";
  document.getElementById('adminCountMajor').value = settings.counts?.["Major Practical"] || "";
  document.getElementById('adminCountViva').value = settings.counts?.Viva || "";

  // Logo preview reset
  const logoInput = document.getElementById("adminLogo");
  if (logoInput) logoInput.value = "";
  const preview = document.getElementById("logoPreview");
  if (preview) {
    if (settings.logo) {
      preview.src = settings.logo;
      preview.style.display = "block";
    } else {
      preview.style.display = "none";
      preview.src = "";
    }
  }

  updateQuestionPreview();
}


function renderExamHeader() {
  const header = document.getElementById('examHeader');
  let html = "";

  // ✅ Show logo at the top
  if (settings.logo) {
    html += `<img src="${settings.logo}" alt="Logo" style="max-height:80px; margin-bottom:8px;">`;
  }

  html += `<div>Online MCQ Examination System</div>`;

  if (settings.author) html += `<div>Made by: ${escapeHTML(settings.author)}</div>`;
  if (settings.college) html += `<div>${escapeHTML(settings.college)}</div>`;
  if (settings.subject) html += `<div>Subject: ${escapeHTML(settings.subject)}</div>`;
  if (settings.subjectCode) html += `<div>Code: ${escapeHTML(settings.subjectCode)}</div>`;
  if (settings.fullMarks) html += `<div>Total Marks: ${settings.fullMarks}</div>`;

  header.innerHTML = html;
}

  // ... your existing functions ...

  function resetSettings() {
    if (confirm("⚠️ This will clear all saved settings (Logo, Author, College, Subject, etc.) and reset them to blank.\n\nDo you want to continue?")) {
      // Clear localStorage
      localStorage.removeItem("offline_mcq_settings_v1");

      // Reset in-memory settings
      settings = {
        durationMin: 30,
        customMsg: "",
        shuffle: false,
        allowAfterTime: false,
        logo: "",
        author: "",
        college: "",
        subject: "",
        subjectCode: "",
        fullMarks: "",
        counts: { Synopsis: 0, "Minor Practical": 0, "Major Practical": 0, Viva: 0 }
      };

      // Clear logo file input
      const logoInput = document.getElementById("adminLogo");
      if (logoInput) logoInput.value = "";

      // Clear logo preview
      const preview = document.getElementById("logoPreview");
      if (preview) {
        preview.src = "";
        preview.style.display = "none";
      }

      // Re-render admin panel
      renderSettingsAdmin();

      alert("✅ Settings have been reset. All fields are now blank.");
    }
  }





/* Export results CSV */
function exportResultsCSV(){
  if(results.length === 0) return alert('No results to export');
  const rows = [['username','totalPercent','synopsis','minor_practical','major_practical','viva','timestamp']];
  results.forEach(r => rows.push([r.username, r.totalScorePercent, r.sectionScores['Synopsis']||0, r.sectionScores['Minor Practical']||0, r.sectionScores['Major Practical']||0, r.sectionScores['Viva']||0, new Date(r.timestamp).toISOString()]));
  const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  download('results.csv', csv, 'text/csv');
}

/* ---------- Import / Export functions ---------- */

function triggerImportUsers(){ $('#impUsersFile').click(); }
function triggerImportQuestions(){ $('#impQFile').click(); }

function importUsersFile(e){
  const f = e.target.files[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=> {
    try {
      const arr = JSON.parse(fr.result);
      if(!Array.isArray(arr)) throw 'bad';
      // expect objects with username,password,photo (photo optional base64)
      users = arr.map(u => ({ username: u.username, password: u.password, photo: u.photo || '' }));
      write(K_USERS, users); alert('Users imported'); renderUsersAdmin();
    } catch (err) { console.error(err); alert('Invalid users JSON'); }
  };
  fr.readAsText(f);
  e.target.value = '';
}
function importQuestionsFile(e){
  const f = e.target.files[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=> {
    try {
      const arr = JSON.parse(fr.result);
      if(!Array.isArray(arr)) throw 'bad';
      questions = arr.map(q => ({ id: q.id || uid(), question: q.question || '', options: q.options || ['','','',''], answer: parseInt(q.answer)||0, marks: parseInt(q.marks)||1, category: q.category || 'Synopsis' }));
      write(K_QS, questions); alert('Questions imported'); renderQuestionsList();
    } catch(err){ console.error(err); alert('Invalid questions JSON'); }
  };
  fr.readAsText(f);
  e.target.value = '';
}

function exportUsers(){ download('users.json', JSON.stringify(users, null, 2), 'application/json'); }
function exportQuestions(){ download('questions.json', JSON.stringify(questions, null, 2), 'application/json'); }
function downloadBackup(){
  const backup = { users, questions, results, admin: read(K_ADMIN, null) };
  download('backup_offline_mcq.json', JSON.stringify(backup, null, 2), 'application/json');
}

function exportResultsJSON(){
  if(results.length === 0) return alert('No results to export');
  download('results.json', JSON.stringify(results, null, 2), 'application/json');
}

function exportResultsCSV(){
  if(results.length === 0) return alert('No results to export');
  const rows = [['username','totalPercent','synopsis','minor','major','viva','timestamp']];
  results.forEach(r => rows.push([
    r.username,
    r.totalScorePercent,
    r.sectionScores['Synopsis']||0,
    r.sectionScores['Minor Practical']||0,
    r.sectionScores['Major Practical']||0,
    r.sectionScores['Viva']||0,
    new Date(r.timestamp).toISOString()
  ]));
  const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  download('results.csv', csv, 'text/csv');
}

async function importResultsFile(e) {
  const files = e.target.files;
  if (!files || files.length === 0) return;

  let allImported = [];

  for (const file of files) {
    const fr = new FileReader();
    await new Promise((resolve, reject) => {
      fr.onload = async () => {
        try {
          const imported = JSON.parse(fr.result);
          const decrypted = await decryptData(imported); // decrypt each file
          allImported = allImported.concat(decrypted);   // merge results
          resolve();
        } catch (err) {
          console.error("Failed to import file", file.name, err);
          alert(`❌ Failed to import ${file.name}`);
          reject(err);
        }
      };
      fr.readAsText(file);
    });
  }

  // 🔒 Re-encrypt merged results before saving
  const encryptedResults = await encryptData(allImported);
  write(K_RESULTS, encryptedResults);
  results = allImported;

  alert(`✅ Imported ${files.length} results file(s) successfully!`);
  renderResults();
  e.target.value = ""; // reset file input
}

function exportSettings() {
  if (!settings) return alert("No exam settings to export");
  download('exam_settings.json', JSON.stringify(settings, null, 2), 'application/json');
}

function triggerImportSettings() {
  document.getElementById('impSettingsFile').click();
}

function importSettingsFile(e) {
  const f = e.target.files[0]; if (!f) return;
  const fr = new FileReader();
  fr.onload = () => {
    try {
      const obj = JSON.parse(fr.result);

      // Merge with defaults and existing settings
      settings = {
        ...settings,
        durationMin: obj.durationMin ?? settings.durationMin ?? 30,
        customMsg: obj.customMsg ?? settings.customMsg ?? "📢 Welcome to your exam! Stay calm, focus, and do your best!",
        shuffle: obj.shuffle ?? settings.shuffle ?? false,
        allowAfterTime: obj.allowAfterTime ?? settings.allowAfterTime ?? false,
        logo: obj.logo ?? settings.logo ?? "",
        author: obj.author ?? settings.author ?? "",
        college: obj.college ?? settings.college ?? "",
        subject: obj.subject ?? settings.subject ?? "",
        subjectCode: obj.subjectCode ?? settings.subjectCode ?? "",
        fullMarks: obj.fullMarks ?? settings.fullMarks ?? 0,
        counts: {
          Synopsis: obj.counts?.Synopsis ?? settings.counts?.Synopsis ?? 0,
          "Minor Practical": obj.counts?.["Minor Practical"] ?? settings.counts?.["Minor Practical"] ?? 0,
          "Major Practical": obj.counts?.["Major Practical"] ?? settings.counts?.["Major Practical"] ?? 0,
          Viva: obj.counts?.Viva ?? settings.counts?.Viva ?? 0
        }
      };

      write(K_SETTINGS, settings);
      alert('✅ Exam settings imported!');
      renderSettingsAdmin(); 
    } catch(err) {
      console.error(err);
      alert('❌ Invalid exam settings JSON');
    }
  };
  fr.readAsText(f);
  e.target.value = '';
}

/* ---------- start UI ---------- */
showSection('user');
renderQuestionsList();
renderUsersAdmin();
renderResults();

// Ensure the login button (which calls handleUserLogin()) calls our resume-aware login.
if (typeof handleUserLogin_withResume === 'function') {
  window.handleUserLogin = (...args) => handleUserLogin_withResume(...args);
  // also expose it directly so older code that expects window.handleUserLogin works
  window.handleUserLogin_withResume = handleUserLogin_withResume;
}


/* Expose a few for console/debug if needed */
window._data = { users, questions, results };

const character = document.getElementById("examCharacterName");
character.textContent = user.fullName;

// Smooth tracking variables
let mouseX = 0, mouseY = 0;
let charX = 0, charY = 0;
const speed = 0.15; // lower = slower lag, higher = faster

// Update mouse position
document.addEventListener('mousemove', e => {
    mouseX = e.clientX + 15; // offset
    mouseY = e.clientY + 15;
});

// Animation loop
function animate() {
    // Move character towards mouse with easing
    charX += (mouseX - charX) * speed;
    charY += (mouseY - charY) * speed;
    character.style.left = charX + 'px';
    character.style.top = charY + 'px';
    requestAnimationFrame(animate);
}

// Start animation
animate();
const ADMIN_UNLOCK_PASS = "exam123"; // 🔑 change this password
let examPaused = false;

// force fullscreen
function enterFullscreen(el) {
  if (el.requestFullscreen) el.requestFullscreen();
  else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
  else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  else if (el.msRequestFullscreen) el.msRequestFullscreen();
}

// detect exit fullscreen
document.addEventListener("fullscreenchange", () => {
  if (!document.fullscreenElement && !EXAM.state?.submitted) {
    pauseExam();
  }
});

async function pauseExam() {
  try {
    examPaused = true;

    // stop the exam timer (defensive)
    if (EXAM && EXAM.timerId) {
      clearInterval(EXAM.timerId);
      EXAM.timerId = null;
    }

    // show lock UI
    const lockNode = document.getElementById("lockScreen");
    if (lockNode) lockNode.style.display = "flex";

    // ensure EXAM.state exists and mark locked explicitly
    if (!EXAM) EXAM = {};
    if (!EXAM.state) EXAM.state = {};
    EXAM.state.locked = true;

    // persist locked state (await so errors are visible in console)
    if (EXAM.state.username) {
      const username = EXAM.state.username;
      try {
        await saveSessionToFirestore(username, EXAM.state, EXAM.paper);
      } catch (e) {
        console.warn("Failed to persist locked state:", e);
      }
      // prefer realtime watcher; stop poller if it exists
      if (typeof stopPausedSessionPolling === "function") stopPausedSessionPolling();
      // attach snapshot watcher (idempotent: implementation should handle re-subscribing)
      if (typeof startSessionWatcher === "function") startSessionWatcher(username);
    } else {
      console.warn("pauseExam: no EXAM.state.username to save session for");
      // fallback: start poller if watcher can't be attached (optional)
      if (typeof startPausedSessionPolling === "function") startPausedSessionPolling(EXAM?.state?.username);
    }
  } catch (err) {
    console.warn("pauseExam error:", err);
  }
}


// 🔹 Unlock Exam with Password (improved)
async function unlockExam() {
  if (!EXAM.state || !EXAM.state.username) {
    alert("⚠️ No active exam session found.");
    return;
  }

  const username = EXAM.state.username;
  const input = document.getElementById("unlockPassword");

  // --- 1) Check server-side session first (in case admin already unlocked) ---
  try {
    const snap = await getDoc(doc(db, "sessions", username));
    if (snap && snap.exists()) {
      const s = snap.data();
      if (!s.locked) {
        // Admin already unlocked -> resume locally
        if (typeof stopPausedSessionPolling === 'function') stopPausedSessionPolling();
        if (typeof stopSessionWatcher === 'function') stopSessionWatcher();

        document.getElementById("lockScreen").style.display = "none";
        try { enterFullscreen(document.documentElement); } catch(e) {}
        try { startTimer(); } catch(e) {}
        examPaused = false;
        EXAM.state.locked = false;
        try { startPeriodicSessionSave(); } catch(e) {}

        alert("✅ Unlocked by admin — resuming exam.");
        input.value = "";
        return;
      }
    }
  } catch (e) {
    console.warn("unlockExam: server check failed", e);
    // continue to password fallback
  }

  // --- 2) Password fallback: accept MASTER_ADMIN or student's password ---
  const pass = (input.value || "").trim();
  if (!pass) {
    alert("⚠️ Please enter a password to unlock.");
    return;
  }

  const userRecord = users.find(u => u.username === username);
  const isMaster = (pass === MASTER_ADMIN.password) || (typeof ADMIN_UNLOCK_PASS !== 'undefined' && pass === ADMIN_UNLOCK_PASS);

  const isStudent = userRecord && userRecord.password && (pass === userRecord.password);

  if (!isMaster && !isStudent) {
    alert("❌ Wrong password. Try again or contact admin.");
    input.value = "";
    return;
  }

  // --- 3) Unlock locally and persist to server (best-effort) ---
  try {
    // update local state
    EXAM.state.locked = false;
    EXAM.state.lockReason = "";
    // Save to sessions collection so admin sees the change
    if (typeof saveSessionToFirestore === 'function') {
      await saveSessionToFirestore(username, EXAM.state, EXAM.paper);
      try {
        await setDoc(doc(db, "sessions", username), { locked: false, unlockedAt: Date.now(), updatedAt: Date.now() }, { merge: true });
      } catch(e){ /* non-fatal */ }
    } else {
      await setDoc(doc(db, "sessions", username), { locked: false, unlockedAt: Date.now(), updatedAt: Date.now() }, { merge: true });
    }
  } catch (err) {
    console.warn("unlockExam: failed to persist unlock to server", err);
    // continue anyway (allow user to resume locally)
  }

  // --- 4) Restore UI & timer ---
  if (typeof stopPausedSessionPolling === 'function') stopPausedSessionPolling();
  if (typeof stopSessionWatcher === 'function') stopSessionWatcher();

  document.getElementById("lockScreen").style.display = "none";
  try { enterFullscreen(document.documentElement); } catch(e) {}
  try { startTimer(); } catch(e) {}
  examPaused = false;
  try { startPeriodicSessionSave(); } catch(e) {}

  alert("✅ Unlocked. Resuming exam.");
  input.value = "";
}

// expose if needed by inline onclick
window.unlockExam = unlockExam;

let PAUSE_POLLER_ID = null;
function startPausedSessionPolling(username) {
  if (!username) return;
  // don't start polling if snapshot is active
  if (SESSION_UNSUBSCRIBE) return;
  stopPausedSessionPolling();
  PAUSE_POLLER_ID = setInterval(async () => {
    try {
      const docRef = doc(db, "sessions", username);
      const snap = await getDoc(docRef);
      if (!snap.exists()) return;
      const s = snap.data();
      if (s.locked) {
        if (document.getElementById("lockScreen")) {
          document.getElementById("lockScreen").style.display = "flex";
        }
        examPaused = true;
        clearInterval(EXAM.timerId);
      } else {
        if (document.getElementById("lockScreen")) {
          document.getElementById("lockScreen").style.display = "none";
        }
        if (examPaused) {
          examPaused = false;
          try { startTimer(); } catch(e){}
        }
      }
    } catch (e) {
      console.warn("pause poller error:", e);
    }
  }, 2500);
}

function stopPausedSessionPolling() {
  if (PAUSE_POLLER_ID) {
    clearInterval(PAUSE_POLLER_ID);
    PAUSE_POLLER_ID = null;
  }
}


// And make sure stopPausedSessionPolling() is called when user unlocks locally (in unlockExam)
// -----------------------
// Auto-lock on any "exit" attempt
// -----------------------

// Helper guard: only lock when exam is active and not already submitted/completed
function shouldAutoLock() {
  // adapt these checks to your app state variables
  // - EXAM.running: (true if exam in progress) - replace if you use another flag
  // - EXAM.submitted: (true if exam already submitted)
  // - examPaused: local paused flag
  const running = !!(typeof EXAM !== "undefined" && EXAM && EXAM.running);
  const submitted = !!(typeof EXAM !== "undefined" && EXAM && EXAM.submitted);
  return running && !submitted && !examPaused;
}

// central function to trigger lock behavior
function triggerAutoLock(reason) {
  try {
    console.log("Auto-lock triggered:", reason);
    // if exam already paused/locked, ignore
    if (!shouldAutoLock()) return;
    // call existing pause logic (which should save locked:true and show lock screen)
    // if you used a different name for pause handler, replace pauseExam() accordingly
    if (typeof pauseExam === "function") {
      pauseExam();
    } else {
      // fallback: set local flags + show lock UI + save session
      examPaused = true;
      if (document.getElementById("lockScreen")) document.getElementById("lockScreen").style.display = "flex";
      if (EXAM && EXAM.state && EXAM.state.username) {
        saveSessionToFirestore(EXAM.state.username, { ...EXAM.state, locked: true }, EXAM.paper).catch(e=>console.warn(e));
      }
      startPausedSessionPolling();
    }
  } catch (e) {
    console.error("triggerAutoLock error:", e);
  }
}

// --------------- Event handlers ------------------

// 1) Detect leaving fullscreen (most browsers fire this when user presses ESC, or window loses fullscreen)
document.addEventListener("fullscreenchange", () => {
  // If we left fullscreen and exam is running -> lock
  if (!document.fullscreenElement) {
    triggerAutoLock("fullscreenchange: left fullscreen");
  }
});

// 2) Detect visibility change (tab switch / minimize / lock-screen)
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    triggerAutoLock("visibilitychange: document.hidden");
  }
});

// 3) Window blur — user clicked outside window or switched app (mobile or desktop)
window.addEventListener("blur", () => {
  // small timeout to avoid false positives from brief focus shifts
  setTimeout(() => {
    if (document.hasFocus && !document.hasFocus()) {
      triggerAutoLock("window.blur: lost focus");
    }
  }, 150);
});

// 4) Pagehide / beforeunload — attempts to close or reload
window.addEventListener("pagehide", (e) => {
  // pagehide occurs when navigating away or closing tab
  triggerAutoLock("pagehide");
});

// beforeunload: can't perform async writes reliably, but we still trigger local lock UI
window.addEventListener("beforeunload", (e) => {
  if (!shouldAutoLock()) return;
  // show lock UI and save synchronous minimal state
  try {
    if (EXAM && EXAM.state && EXAM.state.username) {
      // best-effort save; this is synchronous-ish so keep small
      navigator.sendBeacon && typeof navigator.sendBeacon === "function" && (() => {
        try {
          // If you have an API endpoint to save session quickly, use sendBeacon there.
          // Fallback: still call saveSessionToFirestore but it may not complete before unload.
          saveSessionToFirestore(EXAM.state.username, { ...EXAM.state, locked: true }, EXAM.paper).catch(()=>{});
        } catch(e){}
      })();
    }
  } catch(e) {}
  // Custom message not allowed in many browsers; still we can prompt to stop navigation:
  // e.returnValue = "Are you sure you want to leave the exam? Leaving will lock your session.";
  // return e.returnValue;
});

// 5) Optional: Detect long pointer leave (mouse leaving window) — useful for desktops
document.addEventListener("mouseleave", (e) => {
  // only when pointer leaves window viewport at top (possible closing devtools/window)
  if (e.clientY <= 0) {
    // slight debounce
    setTimeout(() => {
      if (!document.fullscreenElement && shouldAutoLock()) triggerAutoLock("mouseleave: top edge");
    }, 120);
  }
});

// --------------- End auto-lock block ------------------
  
function dismissInstructions(){
  document.getElementById("examInstructionsOverlay").style.display = "none";
}

function showInstructions(){
  document.getElementById("examInstructionsOverlay").style.display = "flex";
}
// ------------------------------
// 👇 Attractive Mouse Trail Effect
// ------------------------------
const trailContainer = document.createElement("div");
trailContainer.style.position = "fixed";
trailContainer.style.top = "0";
trailContainer.style.left = "0";
trailContainer.style.width = "100%";
trailContainer.style.height = "100%";
trailContainer.style.pointerEvents = "none";
trailContainer.style.overflow = "hidden";
trailContainer.style.zIndex = "9999";
document.body.appendChild(trailContainer);

document.addEventListener("mousemove", e => {
  const dot = document.createElement("div");
  dot.style.position = "absolute";
  dot.style.width = "12px";
  dot.style.height = "12px";
  dot.style.borderRadius = "50%";
  dot.style.background = `hsl(${Math.random()*360}, 90%, 60%)`; // rainbow colors
  dot.style.left = e.clientX + "px";
  dot.style.top  = e.clientY + "px";
  dot.style.opacity = "1";
  dot.style.transform = "scale(1)";
  dot.style.transition = "opacity 0.8s linear, transform 0.8s ease";

  trailContainer.appendChild(dot);

  // fade & shrink out
  setTimeout(() => {
    dot.style.opacity = "0";
    dot.style.transform = "scale(0.3)";
    setTimeout(() => dot.remove(), 800);
  }, 20);
});

function updateStats() {
  if (!EXAM.state) return;

  const answered = Object.keys(EXAM.state.answers).length;
  const notAnswered = EXAM.paper.length - answered;
  const flagged = Object.keys(EXAM.state.flags).length;

  document.getElementById("answerStats").innerHTML = `
    <span style="color: var(--good)">Answered: ${answered}</span> |
    <span style="color: var(--danger)">Not Answered: ${notAnswered}</span> |
    <span style="color: orange">Flagged: ${flagged}</span>
  `;
}
function updateQuestionPreview(){
  const s = parseInt(document.getElementById('adminCountSynopsis').value) || 0;
  const m = parseInt(document.getElementById('adminCountMinor').value) || 0;
  const maj = parseInt(document.getElementById('adminCountMajor').value) || 0;
  const v = parseInt(document.getElementById('adminCountViva').value) || 0;

  const total = s + m + maj + v;

  document.getElementById('questionPreview').innerText = 
    "Total Questions: " + total;
}
// Auto-import JSON files on startup
async function autoImportJSON() {
  let imported = false;
  try {
    // Try full backup first
    const res = await fetch("exam_full_backup.json");
    if (res.ok) {
      const backup = await res.json();
      users = backup.users || [];
      questions = backup.questions || [];
      results = backup.results || [];
      settings = backup.settings || settings;
      adminCred = backup.adminCred || MASTER_ADMIN;

      write(K_USERS, users);
      write(K_QS, questions);
      write(K_RESULTS, results);
      write(K_SETTINGS, settings);
      write(K_ADMIN, adminCred);

      showImportMessage("✅ Auto-imported exam_full_backup.json successfully!");
      imported = true;
      return;
    }
  } catch {}

  // Try users.json
  try {
    const resUsers = await fetch("users.json");
    if (resUsers.ok) {
      users = await resUsers.json();
      write(K_USERS, users);
      showImportMessage("✅ Auto-imported users.json successfully!");
      imported = true;
    }
  } catch {}

  // Try questions.json
  try {
    const resQs = await fetch("questions.json");
    if (resQs.ok) {
      questions = await resQs.json();
      write(K_QS, questions);
      showImportMessage("✅ Auto-imported questions.json successfully!");
      imported = true;
    }
  } catch {}

  if (!imported) {
    showImportMessage("⚠️ No JSON file found for auto-import.");
  }
}

// 🔹 Helper to display banner message
function showImportMessage(msg) {
  let banner = document.getElementById("examMsg");

  if (!banner) {
    // create banner if it doesn't exist
    banner = document.createElement("div");
    banner.id = "examMsg";
    banner.style.cssText = `
      width: 100%;
      padding: 8px;
      text-align: center;
      font-weight: bold;
      background: #222;
      color: #34d399;
    `;
    document.body.prepend(banner);
  }

  banner.textContent = msg;
  banner.style.display = "block";   // ensure it's visible
}

// Run on startup
window.addEventListener("DOMContentLoaded", () => {
  initApp();
})

async function loadSettingsFromFirestore() {
  try {
    const snap = await getDoc(doc(db, "settings", "exam"));
    if (snap.exists()) {
      settings = snap.data();
      write(K_SETTINGS, settings); // sync offline copy
      console.log("✅ Loaded settings from Firestore:", settings);
    } else {
      console.warn("⚠️ No settings found in Firestore, using offline copy");
      settings = read(K_SETTINGS, {});
    }
  } catch (err) {
    console.error("❌ Firestore load error (settings):", err);
    settings = read(K_SETTINGS, {});
  }
}
  
async function loadQuestionsFromFirestore() {
  try {
    const qs = [];
    const snap = await getDocs(collection(db, "questions"));
    snap.forEach(docSnap => qs.push(docSnap.data()));
    if (qs.length > 0) {
      questions = qs;
      write(K_QS, questions);
      console.log("✅ Loaded questions from Firestore:", questions);
    }
  } catch (err) {
    console.error("❌ Firestore load error (questions):", err);
    questions = read(K_QS, []);
  }
}
  async function loadUsersFromFirestore() {
  try {
    const arr = [];
    const snap = await getDocs(collection(db, "users"));
    snap.forEach(docSnap => arr.push(docSnap.data()));
    if (arr.length > 0) {
      users = arr;
      write(K_USERS, users);
      console.log("✅ Loaded users from Firestore:", users);
    }
  } catch (err) {
    console.error("❌ Firestore load error (users):", err);
    users = read(K_USERS, []);
  }
}

async function loadSettingsFromFirestore() {
  try {
    const snap = await getDoc(doc(db, "settings", "exam"));
    if (snap.exists()) {
      settings = snap.data();                 // ← overwrite fully
      settings.durationMin = Number(settings.durationMin ?? 30);
      write(K_SETTINGS, settings);            // cache for offline only
      console.log("✅ Settings from Firestore:", settings);
    } else {
      console.warn("⚠️ No settings in Firestore; using local cache");
      settings = read(K_SETTINGS, {});
      settings.durationMin = Number(settings.durationMin ?? 30);
    }
  } catch (e) {
    console.error("❌ Settings load error:", e);
    settings = read(K_SETTINGS, {});
    settings.durationMin = Number(settings.durationMin ?? 30);
  }
}
async function initApp() {
  await loadSettingsFromFirestore();
  await loadQuestionsFromFirestore();
  await loadUsersFromFirestore();

  try {
    await loadResultsFromFirestore();
  } catch (err) {
    console.warn("⚠️ Firestore failed, falling back to local results", err);
    results = read(K_RESULTS, []);  // localStorage fallback
  }

  renderSettingsAdmin();
  renderExamHeader();
  renderQuestionsList();
  renderUsersAdmin();
  renderResults();
   startAnnouncementsListenerForStudents();
}

// Robust alias + fallback binding for resume-aware login handler
document.addEventListener('DOMContentLoaded', () => {
  // If the resume-aware handler exists, expose it as the canonical login function.
  if (typeof handleUserLogin_withResume === 'function') {
    window.handleUserLogin = (...args) => handleUserLogin_withResume(...args);
    // Also ensure the named function exists globally (no-op if already there)
    window.handleUserLogin_withResume = handleUserLogin_withResume;
    console.log('✅ handleUserLogin -> handleUserLogin_withResume aliased');
  } else {
    // If missing, create a safe stub that logs and prevents errors
    window.handleUserLogin = (...args) => {
      console.error('⚠️ handleUserLogin_withResume is not defined yet. Check script order.');
      alert('Internal error: login handler not ready. Open console (F12) for details.');
    };
    console.warn('⚠️ handleUserLogin_withResume not found — installed safe stub.');
  }

  // Additionally, attach to common login button IDs if present, to support direct listeners
  const possibleIds = ['loginBtn', 'btnLogin', 'userLogin', 'userLoginBtn'];
  for (const id of possibleIds) {
    const el = document.getElementById(id);
    if (el) {
      el.removeAttribute('onclick'); // remove inline handler (avoid double-calls)
      el.addEventListener('click', (e) => {
        e.preventDefault();
        try { window.handleUserLogin(); } catch (err) { console.error(err); }
      });
      console.log(`🔗 Bound login handler to #${id}`);
      break; // bind to the first found id
    }
  }

  // If your HTML uses <button onclick="handleUserLogin()"> and that still fails,
  // make sure this script runs AFTER that button is parsed (that's why DOMContentLoaded).
});
// Helper: fetch public IP once
async function getUserIP() {
  try {
    const res = await fetch("https://api.ipify.org?format=json");
    const data = await res.json();
    return data.ip;
  } catch (e) {
    console.warn("⚠️ IP fetch failed", e);
    return "unknown";
  }
}

// Setup visitor session
async function initVisitorSession() {
  let visitorId = localStorage.getItem("visitorId");
  if (!visitorId) {
    visitorId = "v_" + Math.random().toString(36).slice(2,9);
    localStorage.setItem("visitorId", visitorId);
  }

  const ip = await getUserIP();

  // Save/update visitor record in Firestore
  await setDoc(doc(db, "visitors", visitorId), {
    ip,
    visitorId,
    createdAt: Date.now(),
    lastSeen: Date.now()
  }, { merge: true });

  // Start listening for admin messages
  const ref = doc(db, "visitors", visitorId);
  onSnapshot(ref, snap => {
    if (snap.exists()) {
      const data = snap.data();
      if (data.message) {
        // Show message on home page (or custom UI)
      showVisitorMessage(data.message);  // ✅ Replace alert()
      }
    }
  });

  console.log("👤 Visitor session started:", visitorId, ip);
}

document.addEventListener("DOMContentLoaded", () => {
  if (typeof initVisitorSession === "function") {
    initVisitorSession();
  }
});

  async function renderVisitorsAdmin() {
  const out = document.getElementById("adminVisitorsList");
  out.innerHTML = "<div class='small'>Loading visitors…</div>";

  const snap = await getDocs(collection(db, "visitors"));
  if (snap.empty) {
    out.innerHTML = "<div class='small'>No visitors yet.</div>";
    return;
  }

  out.innerHTML = "";
  snap.forEach(docSnap => {
    const v = docSnap.data();
    const div = document.createElement("div");
    div.className = "list-item";
    div.style.display = "flex";
    div.style.justifyContent = "space-between";

    div.innerHTML = `
      <div>
        <div><b>${v.visitorId}</b></div>
        <div class="small">IP: ${v.ip || "unknown"}</div>
        <div class="small">Seen: ${v.lastSeen ? new Date(v.lastSeen).toLocaleTimeString() : "-"}</div>
      </div>
      <div>
        <button class="btn brand" onclick="sendMessageToVisitor('${v.visitorId}')">Message</button>
      </div>
    `;
    out.appendChild(div);
  });
}

  async function sendMessageToVisitor(visitorId) {
  const msg = prompt("Enter message for " + visitorId);
  if (!msg) return;
  await setDoc(doc(db, "visitors", visitorId), {
    message: msg,
    messageAt: Date.now()
  }, { merge: true });
  alert("✅ Message sent to " + visitorId);
}

  
</script>
</body>
</html>




